{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Thanks for taking a look at my GitOps Minicamp 2024 submission! Please use the menu on the left, or click on the \"hamburger\" icon if on mobile to navigate to different areas of the documentation!</p>"},{"location":"#massive-thanks","title":"Massive Thanks!","text":"<p>Massive thanks to Derek Morgan and Andrew Brown for running this GitOps 2024 Minicamp! Show them some  by checking them out below:</p> <p>Derek Morgan</p> <p></p> <ul> <li>MoreThanCertified Courses</li> <li>LinkedIn</li> </ul> <p>Andrew Brown</p> <p></p> <ul> <li>ExamPro</li> <li>LinkedIn</li> </ul>"},{"location":"aws_accounts/","title":"AWS Account Structure","text":"<p>This project has 3 different AWS accounts for different purposes:</p> <ol> <li>Management</li> <li>Dev</li> <li>Prod</li> </ol>"},{"location":"aws_accounts/#diagram","title":"Diagram","text":""},{"location":"aws_accounts/#management-account","title":"Management Account","text":"<p>This account is where the OpenTofu state locking infrastructure is deployed. This consists of:</p> <ol> <li>S3 Bucket</li> <li>DynamoDB Table</li> </ol> <p>As mentioned , Amazon-managed KMS keys have been used for encryption to stay within the free tier."},{"location":"aws_accounts/#dev-account","title":"Dev Account","text":"<p>This AWS account hosts the develop environment of the infrastructure we're building inside the project. This consists of:</p> <ol> <li>Networking resources</li> <li>VPC</li> <li>Route Tables</li> <li>Subnets</li> <li>Security Groups</li> <li>EC2 Instance</li> <li>To run Grafana</li> </ol>"},{"location":"aws_accounts/#prod-account","title":"Prod Account","text":"<p>This AWS account hosts the production environment of the infrastructure we're building inside the project. This consists of:</p> <ol> <li>Networking resources</li> <li>VPC</li> <li>Route Tables</li> <li>Subnets</li> <li>Security Groups</li> <li>EC2 Instance</li> <li>To run Grafana</li> </ol>"},{"location":"tofu_workflow/","title":"OpenTofu Workflow","text":"<p>OpenTofu was used to deploy the infrastructure defined via the bootcamp. I believe passionately in Open Source, and thought this project was the perfect opportunity to use it for the first time! This page covers the workflow I created for this project, and goes over why I made the decisions I did.</p>"},{"location":"tofu_workflow/#state-management","title":"State Management","text":"<p>To manage the state file, we are using the native S3 backend for storage. Followed by DynamoDB for the state locking. Amazon managed encryption keys were used to encrypt the bucket and table.</p> <p>Info</p> <p>In a customer/production situation, I would create dedicated CMKs (customer managed keys). However, I wanted to keep this in the free tier as much as possible.</p> <p>A decision I made here is using separate IAM roles for managing the state file and the deployment of infrastructure. This means we can better adhere to the principal of least privilege as we wouldn't need to give the deployment role (the role that Terraform assumes to actually deploy infrastructure) permissions to also use the state file. This is super useful if you store your state file in a separate AWS account and is easy to implement. OpenTofu and Terraform can have two distinct authentication mechanisms:</p> <ol> <li>Accessing the state file (using the <code>backend \"s3\" {}</code> block)</li> <li>Deploying resources (using the <code>provider \"aws\" {}</code> block)</li> </ol> <p>If you don't explicitly configure the state file authentication, the authentication you configure at the <code>provider</code> level is used to access the <code>backend</code>.</p> <p>Diagram</p> <p>A diagram has been created below showing how the state file management has been configured along with a high level n account (e.g. dev, test, prod etc.) to show the separation.</p> <p></p> <p>Info</p> <p>The rest of the workflow follows the traditional write, plan and apply workflow. You can find more information about this on OpenTofu's website: https://opentofu.org/docs/intro/core-workflow/</p> <p>You can view more information on what these environment variables are at:</p> <ul> <li>TF_IN_AUTOMATION</li> </ul> <p>Quote (from opentofu.org)</p> <p>If <code>TF_IN_AUTOMATION</code> is set to any non-empty value, OpenTofu adjusts its output to avoid suggesting specific commands to run next. This can make the output more consistent and less confusing in workflows where users don't directly execute OpenTofu commands, like in CI systems or other wrapping applications.</p> <p>This is a purely cosmetic change to OpenTofu's human-readable output, and the exact output differences can change between minor OpenTofu versions.</p> <ul> <li>TF_INPUT</li> </ul> <p>Quote (from opentofu.org)</p> <p>If set to \"false\" or \"0\", causes tofu commands to behave as if the <code>-input=false</code> flag was specified. This is used when you want to disable prompts for variables that haven't had their values specified.</p>"},{"location":"tofu_workflow/#partial-backend-configuration","title":"Partial Backend Configuration","text":"<p>This Minicamp implements what is known as a \"partial\" backend configuration. This is where some of the backend is declared in the <code>backend</code> block, but some are passed in as CLI flags or as files to the <code>tofu init</code> command. </p> <p>You can see the <code>backend</code> block below:</p> tofu/provider.tf<pre><code>backend \"s3\" {\n  bucket         = \"mtc-gitops2024-terraform-state-a12b\"\n  encrypt        = true\n  kms_key_id     = \"arn:aws:kms:eu-west-2:195275655961:key/77235df8-1d9e-4340-af90-e95a615ce943\"\n  region         = \"eu-west-2\"\n  dynamodb_table = \"mtc-gitops2024-terraform-state-locks-a12b\"\n  assume_role_with_web_identity = {\n    role_arn                = \"arn:aws:iam::195275655961:role/mtc-gitops2024-terraform-state-role\"\n    session_name            = \"mtc-gitops2024-state-access\"\n    web_identity_token_file = \"/tmp/web-identity-token\"\n    duration                = \"15m\"\n  }\n}\n</code></pre> <p>You may notice the <code>key</code> is missing from this, which points to the location of the state file in the S3 bucket. In my workflow, this is added inside the <code>tofu init</code> commands when the workflows run:</p> .github/workflows/tofu_plan.yml<pre><code>tofu init --backend-config=\"key=${{ github.event.repository.name }}/${{ inputs.environment }}/terraform.tfstate\" --var-file=\"${{ inputs.tf_var_file }}\"\n</code></pre> <p>I made this decision so I am sure the right state file for the right environment is always present, where as using different files could be prone to human error where it refers to the wrong state, even worse if you're not paying attention and then approve it to deployment!</p>"},{"location":"tofu_workflow/#write","title":"Write","text":"<p>I like to keep everything related to the configuration of OpenTofu to itself as much as possible. What do I mean by this? For example: the role that OpenTofu uses to deploy infrastructure, I define it using the <code>assume_role_with_web_identity</code> block directly in the configuration itself. The role OpenTofu uses to configure the remote backend, again using the <code>assume_role_with_web_identity</code> block inside the <code>backend \"s3\" {}</code> block directly in the code. The version of OpenTofu to use, I use the <code>required_version</code> argument in the <code>terraform</code> block to control what versions of OpenTofu can be used.</p> <p>With some of these, you can pass in config via different files, such as <code>.hcl</code> for different backend configurations. How the authentication/authorisation works, you can pass in environment variables and CLI flags to configure it. It's awesome that this flexibility exists, but when someone looks at my code, I want to give them one common, standardised way everything is configured. </p> <p>For an engineer to understand the authentication flow, I don't want them having to go to the OpenTofu configuration, see some of it is there and then have to go to the workflow to see what roles are being used etc. </p> <p>I know what you might be thinking, didn't you do this for the state file, you used a partial backend configuration right? I did, but I've been in situations before where the wrong backend was configured for an environment and well, you can probably guess what happened next. Yes, you can technically rollback if your configuration is in git (it should be by the way!) but all that infrastructure still has to be deployed again; it doesn't magically reappear.</p>"},{"location":"tofu_workflow/#versions-and-providers","title":"Versions and Providers","text":""},{"location":"tofu_workflow/#opentofu-versions","title":"OpenTofu Versions","text":"<p>I've configured the OpenTofu GitHub Action to always use the latest version of OpenTofu at runtime. This is as opposed to specifying a specific version of OpenTofu to run by passing in the variable into the Action. The control over which version to use is managed in the <code>required_version</code> argument of the <code>terraform</code> block:</p> tofu/provider.tf<pre><code>terraform {\n  required_version = \"&gt;= 1.8.3, &lt; 2.0.0\"\n</code></pre> <p>Note</p> <p>If the version constraint above does not meet the latest OpenTofu version, we would need to pass in which version to use to the OpenTofu Action.</p>"},{"location":"tofu_workflow/#providers","title":"Providers","text":"<p>The providers used are:</p> <ol> <li>aws</li> <li>http</li> </ol> tofu/provider.tf<pre><code>required_providers {\n  aws = {\n    source  = \"hashicorp/aws\"\n    version = \"&gt;= 5.0.0, &lt; 6.0.0\"\n  }\n  http = {\n    source  = \"hashicorp/http\"\n    version = \"&gt;= 3.0.0, &lt; 4.0.0\"\n  }\n}\n</code></pre>"},{"location":"tofu_workflow/#aws","title":"aws","text":"tofu/provider.tf<pre><code>provider \"aws\" {\n  region = var.region\n\n  assume_role_with_web_identity {\n    role_arn                = var.deployment_role_arn\n    session_name            = var.role_session_name\n    web_identity_token_file = \"/tmp/web-identity-token\"\n    duration                = \"15m\"\n  }\n\n  default_tags {\n    tags = {\n      project     = \"morethancertified\"\n      environment = var.environment\n    }\n  }\n}\n</code></pre> <p>Inside all OpenTofu actions in the workflows, we use <code>curl</code> to get the OIDC token file that saves it in <code>/tmp/web-identity-token</code>, we then use this to configure the <code>assume_role_with_web_identity</code> block at the <code>backend</code> level and <code>provider</code> level as we are using different roles to interact with the backend, and another to deploy infrastructure.</p> <p>Now, why am I not using the official AWS <code>aws-actions/configure-aws-credentials</code> GitHub Action. Simply put this Action is a 1-2-1 relationship with itself and ONE role - as we are using multiple roles here it would mean I would have to configure this Action twice. To keep the workflow as small as possible, and as I want to keep everything configured using OpenTofu as much as possible it made sense to do it this way.</p> <p>Unfortunately it isn't like the official GCP (Google Cloud Platform) GitHub Action that can output a token file for use.</p> <p>I'm also using the <code>default_tags</code> block, which is a requirement of the minicamp, but I've used this as soon as it was released, I think, in Version 4 of the AWS provider? It's much nicer to use now than back then, those \"inconsistent final plan\" error messages were a pain to deal with!</p> <p>Here the tags <code>project=morethancertified</code> and <code>environment=dev/prod</code> are applied to all taggable resources declared as part of the configuration. This beats having to specify the <code>tags</code> block for each resource! You can still do this however to override and/or apply specific tags to specific resources, but this makes it much easier! </p>"},{"location":"tofu_workflow/#http","title":"http","text":"<p>This provider, and it's only data source is to verify application availability using <code>check</code> blocks.</p> tofu/instance.tf<pre><code>check \"grafana_health_check\" {\n  data \"http\" \"test_access\" {\n    url = \"http://${aws_instance.grafana_server.public_ip}:3000\"\n    retry {\n      attempts = 5\n    }\n  }\n\n  assert {\n    condition     = data.http.test_access.status_code == 200\n    error_message = \"Grafana server is not accessible!\"\n  }\n}\n</code></pre>"},{"location":"tofu_workflow/#variable-validation","title":"Variable Validation","text":"<p>Variable validation has also been implemented to enforce specific values, or a match against a pattern:</p> tofu/variables.tf<pre><code>variable \"environment\" {\n  type        = string\n  description = \"Name of the environment infrastrucutre is being deployed to\"\n\n  validation {\n    condition     = contains([\"dev\", \"prod\"], var.environment)\n    error_message = \"${format(\"%#v\", var.environment)} is not a valid environment. Allowed values are: ${format(\"%#v\", [\"mgmt\", \"dev\", \"test\", \"prod\"])}!\"\n  }\n}\n\nvariable \"region\" {\n  type        = string\n  description = \"AWS region to deploy resources to\"\n\n  validation {\n    condition     = contains([\"eu-west-2\"], var.region)\n    error_message = \"${format(\"%#v\", var.region)} is not a valid region. Allowed values are: ${format(\"%#v\", [\"eu-west-2\"])}!\"\n  }\n}\n\nvariable \"instance_name\" {\n  type        = string\n  description = \"Name of the Grafana instance\"\n\n  validation {\n    condition     = can(regex(\"^[a-z0-9-]+$\", var.instance_name))\n    error_message = \"${format(\"%#v\", var.instance_name)} is not a valid instance name. Ensure your instance name is alphanumeric and lowercase!\"\n  }\n}\n\nvariable \"instance_type\" {\n  type        = string\n  description = \"Instance size to use for the Grafana server\"\n\n  validation {\n    condition     = contains([\"t3.micro\"], var.instance_type)\n    error_message = \"${format(\"%#v\", var.instance_type)} is not a valid instance type. Allowed values are: ${format(\"%#v\", [\"t3.micro\"])}!\"\n  }\n}\n\nvariable \"volume_size\" {\n  type        = number\n  description = \"Size of the root EBS volume (in GB) for the Grafana instance\"\n  default     = 8\n\n  validation {\n    condition     = var.volume_size &lt;= 10\n    error_message = \"${format(\"%#v\", var.volume_size)} is not valid! It must be less than or equal to 10.\"\n  }\n}\n\nvariable \"additional_tags\" {\n  type        = map(string)\n  description = \"Apply additional tags to Grafana instance\"\n\n  validation {\n    condition     = alltrue([for key in keys(var.additional_tags) : can(regex(\"^[a-z0-9-]+$\", key))])\n    error_message = \"All keys in your additional tags must be alphanumeric and lowercase! If word seperation is present, use hyphens (-).\"\n  }\n\n  validation {\n    condition     = anytrue([for key in keys(var.additional_tags) : startswith(\"aws:\", key)]) ? false : true\n    error_message = \"You cannot use tags that begin with 'aws:' as they are reserved for AWS use.\"\n  }\n\n  validation {\n    condition     = alltrue([for key in keys(var.additional_tags) : length(key) &gt;= 1 &amp;&amp; length(key) &lt;= 128])\n    error_message = \"All keys in your additional tags must be at least 1 character long and no more than 128 characters long.\"\n  }\n\n  validation {\n    condition     = alltrue([for value in values(var.additional_tags) : length(value) &gt;= 0 &amp;&amp; length(value) &lt;= 256])\n    error_message = \"All values in your additional tags must be at least 0 characters long and no more than 256 characters long.\"\n  }\n}\n\nvariable \"deployment_role_arn\" {\n  type        = string\n  description = \"The ARN of the role to assume when deploying resources\"\n\n  validation {\n    condition     = can(regex(\"^arn:aws:iam::[0-9]{12}:role/[a-zA-Z0-9+=,.@_-]+$\", var.deployment_role_arn))\n    error_message = \"${format(\"%#v\", var.deployment_role_arn)} is not a valid ARN!\"\n  }\n}\n\nvariable \"role_session_name\" {\n  type        = string\n  description = \"The name of the session when assuming the role\"\n\n  validation {\n    condition     = can(regex(\"^[a-zA-Z0-9+=,.@_-]+$\", var.role_session_name))\n    error_message = \"${format(\"%#v\", var.role_session_name)} is not a valid session name!\"\n  }\n}\n</code></pre> <p>I won't go into massive detail about each one, as some use the same techniques, but give a overview of clear differences.</p> <p>Variable validations are defined using the <code>validation</code> block. A variable can have zero to many <code>validation</code> blocks as you see fit. They are made up of two parameters only - <code>condition</code> and <code>error_message</code>:</p> <pre><code>validation {\n  condition     =\n  error_message = \n}\n</code></pre> <p>The condition MUST return a boolean, <code>true</code> or <code>false</code>. The former meaning the validation has passed, and the latter raising the <code>error_message</code> and stopping the specific action with an error, such as <code>tofu plan</code>.</p> <p>Example 1</p> <pre><code>variable \"environment\" {\n  type        = string\n  description = \"Name of the environment infrastructure is being deployed to\"\n\n  validation {\n    condition     = contains([\"dev\", \"prod\"], var.environment)\n    error_message = \"${format(\"%#v\", var.environment)} is not a valid environment. Allowed values are: ${format(\"%#v\", [\"mgmt\", \"dev\", \"test\", \"prod\"])}!\"\n  }\n}\n</code></pre> <p>The <code>contains()</code> function returns <code>true</code> or <code>false</code> depending whether <code>var.environment</code> contains <code>dev</code> or <code>prod</code>. We use the <code>format()</code> function in the error message to present the value that is invalid to the user. The <code>%#v</code> statement tells the <code>format()</code> function to escape it using JSON which means we can safe print in the terminal.</p> <p>Example 2</p> <pre><code>variable \"instance_name\" {\n  type        = string\n  description = \"Name of the Grafana instance\"\n\n  validation {\n    condition     = can(regex(\"^[a-z0-9-]+$\", var.instance_name))\n    error_message = \"${format(\"%#v\", var.instance_name)} is not a valid instance name. Ensure your instance name is alphanumeric and lowercase!\"\n  }\n}\n</code></pre> <p>This example uses the <code>can()</code> and <code>regex()</code> functions to check the name of the instance is lowercase, alphanumeric and contains hyphens only. The <code>regex()</code> function would return a value if it matches, but not a boolean. This is where we use the <code>can()</code> function. If the input of <code>can()</code> succeeds, which in this case is the <code>regex()</code> function, it returns <code>true</code>, if the input errors, which would mean <code>regex()</code> didn't find a match, <code>can()</code> would return <code>false</code>. </p> <p>Like the example above, we use the <code>format()</code> function to present the bad value to the user.</p> <p>Example 3</p> <pre><code>variable \"volume_size\" {\n  type        = number\n  description = \"Size of the root EBS volume (in GB) for the Grafana instance\"\n  default     = 8\n\n  validation {\n    condition     = var.volume_size &lt;= 10\n    error_message = \"${format(\"%#v\", var.volume_size)} is not valid! It must be less than or equal to 10.\"\n  }\n}\n</code></pre> <p>This example uses a condition to check whether the volume size is less than, or equal too 10. If it's bigger, it returns <code>false</code> and if it is 10 or less, it returns <code>true</code></p> <p>Example 4</p> <pre><code>variable \"additional_tags\" {\n  type        = map(string)\n  description = \"Apply additional tags to Grafana instance\"\n\n  validation {\n    condition     = alltrue([for key in keys(var.additional_tags) : can(regex(\"^[a-z0-9-]+$\", key))])\n    error_message = \"All keys in your additional tags must be alphanumeric and lowercase! If word separation is present, use hyphens (-).\"\n  }\n\n  validation {\n    condition     = anytrue([for key in keys(var.additional_tags) : startswith(\"aws:\", key)]) ? false : true\n    error_message = \"You cannot use tags that begin with 'aws:' as they are reserved for AWS use.\"\n  }\n\n  validation {\n    condition     = alltrue([for key in keys(var.additional_tags) : length(key) &gt;= 1 &amp;&amp; length(key) &lt;= 128])\n    error_message = \"All keys in your additional tags must be at least 1 character long and no more than 128 characters long.\"\n  }\n\n  validation {\n    condition     = alltrue([for value in values(var.additional_tags) : length(value) &gt;= 0 &amp;&amp; length(value) &lt;= 256])\n    error_message = \"All values in your additional tags must be at least 0 characters long and no more than 256 characters long.\"\n  }\n}\n</code></pre> <p>As this variable is a <code>map(string)</code>, we need to validate the entire input. The validation in this does multiple things which ensures it meets AWS recommendations for tagging standards and requirements.</p> <p>Here we loop over all the keys in the map using the <code>keys()</code> function. This returns a list of keys from a <code>map</code>. We then use the <code>startswith()</code> function to check whether each key starts with <code>aws:</code>. If it does, it returns <code>true</code> for that key or <code>false</code> if it starts with something else. Now this is a reserved tag that you cannot create as AWS won't allow you too. </p> <p>Assuming we have 5 additional tags, meaning 5 keys, and all starting with <code>aws:</code> our loop now looks like this:</p> <pre><code>[true, true, true, true, true]\n</code></pre> <p>We then use the <code>anytrue()</code> function, which takes a list and if any items in the list are/contain <code>true</code> it returns <code>true</code> or <code>false</code>:</p> <pre><code>&gt; anytrue([true, true, true, true, true])\ntrue\n</code></pre> <p>Now obviously we cannot create a tag starting with <code>aws:</code> so we use conditional logic in the form of: <code>condition ? true_value : false_value</code>. So since we know it our example returns <code>true</code> in the condition, so now we have told OpenTofu to report this as <code>false</code> - meaning raise the validation error!</p> <p>Tip</p> <p>There are other ways you could implement this, such as using <code>!</code> in front of a function which basically negates the output, essentially reversing the normal operation. So if <code>anytrue()</code> returns <code>true</code>, <code>!anytrue()</code> would return <code>false</code>.</p> <p>I super recommend using <code>tofu console</code> to test custom validation logic out as it's super powerful. You don't have to run a <code>tofu plan</code> each time, just run <code>tofu console</code> and you get a sandbox to test OpenTofu functions!</p>"},{"location":"tofu_workflow/#checks","title":"Checks","text":"<p><code>check</code> blocks are an additional way of validation, but instead of erroring out the run it shows a warning instead and doesn't interfere with the OpenTofu operation.</p> <p>We use one <code>check</code> block inside this project:</p> tofu/instance.tf<pre><code>check \"grafana_health_check\" {\n  data \"http\" \"test_access\" {\n    url = \"http://${aws_instance.grafana_server.public_ip}:3000\"\n    retry {\n      attempts = 5\n    }\n  }\n\n  assert {\n    condition     = data.http.test_access.status_code == 200\n    error_message = \"Grafana server is not accessible!\"\n  }\n}\n</code></pre> <p>Here we're using the <code>http</code> provider to check whether it can access the Grafana instance we have created on AWS! One key difference between variable validation and check blocks are that checks use <code>assert</code> instead of <code>validation</code> - but the logic in how they are evaluated is the same. If true, warning not raised, otherwise raise warning.</p> <p>The <code>http</code> data source is referred to as a <code>scoped</code> data source, which basically means it cannot be accessed outside of the <code>check</code> block that contains it.</p>"},{"location":"tofu_workflow/#testing","title":"Testing","text":"<p>We can use the <code>tofu test</code> framework to build out tests to further validate configuration. As part of this minicamp, we've got 3 test files with multiple tests. An example is below:</p> tofu/tests/account.tftest.hcl<pre><code>run \"deployment_account\" {\n  command = plan\n\n  plan_options {\n    refresh = false\n  }\n\n  assert {\n    condition     = (var.environment == \"dev\" &amp;&amp; data.aws_caller_identity.current.account_id == \"954976300695\") ? true : (var.environment == \"prod\" &amp;&amp; data.aws_caller_identity.current.account_id == \"816069156152\") ? true : false\n    error_message = \"Dev must be deployed to the 954976300695 account! Prod must be deployed to the 816069156152 account!\"\n  }\n\n  expect_failures = [\n    check.grafana_health_check\n  ]\n}\n</code></pre> <p>This test ensures we are deploying to the correct AWS account based on the environment that we are working on. We say run this as a <code>plan</code> test, specifically not to refresh the state (which OpenTofu does when you run a <code>tofu plan</code>) as it's not used in this test.</p> <p>You can also see an <code>expect_failures</code> argument here too, which tells the test expect this <code>check</code> block to fail, which is actually our check block checking Grafana is available. </p> <p>Note</p> <p>Although the <code>check</code> block is not in scope of the <code>tests</code> directory in <code>tofu/</code> it still checks the check block (pardon the pun) which was annoying as technically the <code>check</code> block isn't even in scope of the tests <code>tofu test</code> is meant to run. But for now this is how it works.</p>"},{"location":"tofu_workflow/#plan","title":"Plan","text":"<p>The next part of the core OpenTofu workflow is planning to check what changes it wants to make.</p>"},{"location":"tofu_workflow/#plan-file","title":"Plan File","text":"<p>Throughout this Minicamp we create the plan file but don't actually use it when it comes to the <code>tofu apply</code> - we could do this using the upload artifact and download artifact GitHub Actions but in general it is best practice to encrypt it as it may contain sensitive information, or anything you might \"deem\" sensitive. You can actually do this in OpenTofu itself now natively, it's one of the key differentiators when compared directly with Terraform. The benefit of the plan file approach is that OpenTofu doesn't do another <code>plan</code> when you <code>apply</code>. When you specify <code>--auto-approve</code> OpenTofu generates another plan and then executes it. This has two potential issues:</p> <ol> <li>Speed - Using the plan file from the <code>plan</code> step you can execute the changes much quicker as there's no need for a second \"plan\".</li> <li>Guarantee of Changes - Depending on the time gap between the plan running and then someone approving the workflow to apply the changes, someone could have made some manual changes that were not captured in that first plan. Normally if you execute an <code>apply</code> right after the <code>plan</code> this is unlikely, but sometimes you might go a few hours or potentially days if you waiting to do a change based on any change management process.</li> </ol> <p>Note</p> <p>One of the aims for further steps is to implement the plan file workflow approach!</p>"},{"location":"tofu_workflow/#apply","title":"Apply","text":"<p>We take the output of the plan, and then make a decision on whether we want to tell OpenTofu to attempt to deploy those \"planned\" changes.</p>"},{"location":"tofu_workflow/#destroy","title":"Destroy","text":"<p>Once we're done with the infrastructure, we will destroy it! Now this step isn't normally part of the core OpenTofu workflow officially; it's just Write, Plan and Apply. Obviously if the infrastructure was serving an actual service that end customers pay for, it's a different story, but this is a Minicamp. Cost control has taken over the industry by storm, with terms used that you might be aware of like FinOps. There's even a FinOps Foundation: https://www.finops.org/. </p> <p>I personally believe that cost should be everyone's responsibility, although you might not be typically involved as an engineer in finance. However, engineers ultimately deploy the infrastructure that creates the bills! Typically cost is reactive, I mean, once you get your bill it's basically too late. Instead we should be more proactive, and tools such as Infracost are one way where we can govern cost before the changes are made to infrastructure.</p>"},{"location":"whats_next/","title":"What's Next?","text":"<p>This Minicamp has been amazing for me! I've dabbled in GitHub Actions before and actively continue to do so, but it was amazing putting it to the test and creating something actually tangible. Given the time I had, I've created so much. However, I've already identified improvements I would love to make and will continue to do so in my own time. I'm explaining some of them below!</p>"},{"location":"whats_next/#caching-providers","title":"Caching Providers","text":"<p>OpenTofu Providers are big, hundreds of megabytes! The AWS OpenTofu Provider 5.74 Linux AMD64 version is 603.80MB in fact. Instead of downloading these each time, it would be good to cache them as opposed to downloading them each time. Especially in frequent runs.</p>"},{"location":"whats_next/#use-the-opentofu-plan-file-approach","title":"Use the OpenTofu Plan File Approach","text":"<p>I've explained this in OpenTofu Workflow but will show an excerpt below:</p> <p>Quote</p> <p>Throughout this Minicamp we create the plan file but don't actually use it when it comes to the <code>tofu apply</code> - we could do this using the upload artifact and download artifact GitHub Actions but in general it is best practice to encrypt it as it may contain sensitive information, or anything you might \"deem\" sensitive. You can actually do this in OpenTofu itself now natively, it's one of the key differentiators when compared directly with Terraform. The benefit of the plan file approach is that OpenTofu doesn't do another <code>plan</code> when you <code>apply</code>. When you specify <code>--auto-approve</code> OpenTofu generates another plan and then executes it. This has two potential issues:</p> <ol> <li>Speed - Using the plan file from the <code>plan</code> step you can execute the changes much quicker as there's no need for a second \"plan\".</li> <li>Guarantee of Changes - Depending on the time gap between the plan running and then someone approving the workflow to apply the changes, someone could have made some manual changes that were not captured in that first plan. Normally if you execute an <code>apply</code> right after the <code>plan</code> this is unlikely, but sometimes you might go a few hours or potentially days if you waiting to do a change based on any change management process.</li> </ol>"},{"location":"whats_next/#apply-before-merge","title":"Apply Before Merge","text":"<p>Again, I've explained this further in the Merging Strategy, but will show an excerpt below:</p> <p>Quote</p>"},{"location":"whats_next/#implement-chatops","title":"Implement ChatOps","text":"<p>One thing I'm seeing a lot lately in industry is using \"ChatOps\" - where we can influence CI/CD in our PRs using \"slash commands\", such as:</p> <ol> <li><code>/replan</code></li> <li><code>/apply</code></li> </ol> <p>Which could run a new Terraform Plan and apply directly in the PR itself, also known as \"Apply before Merge\" as discussed above. I would like to explore this behaviour and implement it. In fact I did try for this Minicamp, but due to time I didn't implement it.</p>"},{"location":"whats_next/#create-pr-comment-following-apply","title":"Create PR Comment following Apply","text":"<p>Another nice quality of life improvement to this would be to create a comment on the PR following the <code>tofu apply</code> step. Once the apply has been ran from the PR that generated the event.</p>"},{"location":"whats_next/#workflow-refactoring","title":"Workflow Refactoring","text":"<p>My reusable workflows are very much tailored to my specific Minicamp implementation, so while they are reusable for \"me\", I would like to make them more generic where possible so others could use them. However in saying that, there are loads of workflows out there that are already adopted by communities as the \"defacto\" standard. One example that springs to mind is my use if <code>github-script</code> to post comments to PRs. There's Actions out there that do this for you and abstract the complexity away from you. I wanted to push myself and my own learning in keeping as close to official, native Actions where possible but I'm all for not reinventing the wheel. If something already exists, I'd much rather build on it and contribute anything back so others can leverage!</p>"},{"location":"whats_next/#repo-management-in-opentofu","title":"Repo Management in OpenTofu","text":"<p>I created the repo on the console manually, I would like to have the repo and the associated settings managed by OpenTofu itself using the GitHub provider. Given more time, I would have done this, and I can easily do so by importing it into Terraform.</p>"},{"location":"whats_next/#checkov-workflow","title":"checkov Workflow","text":"<p>I mentioned in the SAST Tooling page that the official Checkov action hasn't been updated in a very long time, and even using one major version out-of-date version of checkov. One easy improvement I could make is to create a new one and manage it through <code>pip</code>.</p>"},{"location":"whats_next/#checkov-sarif-output","title":"checkov Sarif Output","text":"<p>checkov can output the results into a sarif format. This could then be uploaded to the \"Security\" tab of the repository if using GitHub Advanced Security. I'd need to check, but public repos get it enabled automatically I think, so this could be easy to implement!</p>"},{"location":"whats_next/#generate-opa-policies","title":"Generate OPA Policies","text":"<p>Currently I have only one OPA policy that Infracost uses to check the cost of a PR doesn't exceed $10. It would be good to generate further policies, such as:</p> <ol> <li>Making sure 0.0.0.0/0 isn't exposed on Port 22 (SSH)</li> <li>Only certain instance types are allowed</li> </ol> <p>Yes, you could technically use OpenTofu variable validation, pre and postconditions in modules to enforce this, but I feel OPA gives a more agnostic way of adhering to a common set of policies. Whether you are using modules that enforce these or not - you'll be assessed against the same standard.</p>"},{"location":"whats_next/#grafana-port-check-workflow-improvements","title":"Grafana Port Check Workflow Improvements","text":"<p>Currently the workflow is hardcoding the IP addresses, which means I have an external dependency. It would be good to store the IPs somewhere, such as SSM Parameter Store in AWS which is free, and have it dynamically get them at runtime. As I'm writing this, I could easily use workflow variables or/and even give access to the state file using <code>outputs</code> to get the information too. This should be easy to integrate.</p>"},{"location":"whats_next/#dependabot","title":"Dependabot","text":"<p>I have dabbled with this already, and got it working in the repo as you can see below for creating PRs on new versions of Workflows:</p> <p></p> <p>but I would like to deep dive into this more and see what is possible, such as AWS Provider Version upgrades and more!</p>"},{"location":"github_action_workflows/","title":"GitHub Action Workflows","text":"<p>Full CI/CD functionality is done in GitHub Actions. Each section below contains documentation covering what each workflow does and the purpose it solves. Workflows used are a combination of static and reusable.</p> <p>To keep it simple, all of these Actions are using the <code>ubuntu-latest</code> GitHub-hosted Action Runners denoted by the <code>runs-on:</code> keyword.</p>"},{"location":"github_action_workflows/#using-commit-shas-instead-of-git-tags","title":"Using \"commit SHAs\" instead of \"Git tags\"","text":"<p>As you read this page, you will see I'm using commit SHAs for each external GitHub Action instead of the appropriate git tag, normally based on the semver standard. This is more of a security decision and tools such as checkov and trivy can actually analyse your workflows and recommend you do this too. This is to help mitigate against supply chain attacks. </p> <p>A git tag is just a pointer to a specific commit SHA, these tags can be updated to point at a new reference if forced pushed by someone with appropriate permissions. As a result, Git tags are not immutable. So if you reference <code>v1</code> which points to <code>a12b3c4d</code>, then someone updates the <code>v1</code> tag to <code>d56e7f8g9h</code> then your workflow will point to the new commit. While this helps get updates quickly, it could mean your workflow is running code that you've not validated. More importantly, if the new pointer has something malicious, then it could cause serious impact.</p> <p>You can see examples of this below:</p> Examples<pre><code>- name: Check Out Code\n  uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2 (1)\n\n- name: Configure OpenTofu\n  uses: opentofu/setup-opentofu@12f4debbf681675350b6cd1f0ff8ecfbda62027b # v1.0.4\n\n- name: Create Issue if Drift Detected\n  if: steps.plan-dev.outputs.exitcode == 2\n  uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1\n</code></pre> <ol> <li>I've added a comment of the tag the commit sha points to, which helps developers know what version of an action is ran. In this case it is <code>v4.2.2</code> of the official <code>checkout</code> GitHub action.</li> </ol>"},{"location":"github_action_workflows/drift_check/","title":"Tofu Drift Check","text":"<p>This workflow creates a GitHub Issue if drift is detected on both the <code>dev</code> and <code>prod</code> environments. Drift is when the state of your infrastructure differs from the state known by OpenTofu.</p>"},{"location":"github_action_workflows/drift_check/#workflow","title":"Workflow","text":".github/workflows/drift_check.yml<pre><code>name: Tofu Drift Check\n\non:\n  schedule:\n    - cron: 0 17 * * * #5pm every day\n  workflow_dispatch: {}\n\npermissions:\n  issues: write\n  contents: read\n  id-token: write\n\njobs:\n  dev:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check Out Code\n        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n\n      - name: Configure OpenTofu\n        uses: opentofu/setup-opentofu@12f4debbf681675350b6cd1f0ff8ecfbda62027b # v1.0.4\n\n      - name: Print Tofu Version\n        run: tofu --version\n\n      - name: Get OIDC Token File\n        run: |\n          curl -s -H \"Authorization: bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN\" \"$ACTIONS_ID_TOKEN_REQUEST_URL&amp;audience=sts.amazonaws.com\" | jq -r .value &gt; /tmp/web-identity-token\n\n      - name: Tofu Init\n        run: tofu init --backend-config=\"key=${{ github.event.repository.name }}/dev/terraform.tfstate\" --var-file=\"dev.tfvars\"\n        working-directory: ${{ github.workspace }}/tofu\n\n      - name: Tofu Plan\n        id: plan-dev\n        run: tofu plan --var-file=\"dev.tfvars\" -no-color -detailed-exitcode -out=tfdev.plan\n        working-directory: ${{ github.workspace }}/tofu\n\n      - name: Create Issue if Drift Detected\n        if: steps.plan-dev.outputs.exitcode == 2\n        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1\n        with:\n          script: |\n            const fs = require('fs');\n            const { execSync } = require('child_process');\n\n            // Get the terraform plan output\n            const planOutput = execSync('tofu show -no-color tfdev.plan', {\n              cwd: 'tofu'\n            }).toString();\n\n            const plan = planOutput.length &gt; 65000 ? planOutput.substring(0, 65000) + \" ...\" : planOutput;\n\n            const truncateMessage = planOutput.length &gt; 65000 ? `&gt; [!NOTE]\\n&gt; The plan output is too long so it has been truncated. You can view the full plan at: ${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}` : \"\";\n\n            const issueTitle = 'Drift detected in DEV';\n            const issueBody = `# Drift has been detected in \\`dev\\`.\\nBelow is the plan output:\\n&lt;details&gt;&lt;summary&gt;Show Plan&lt;/summary&gt;\\n\\n\\`\\`\\`hcl\\n${plan}\\n\\`\\`\\`\\n&lt;/details&gt;\\n\\n${truncateMessage}`;\n            const issues = await github.rest.issues.listForRepo({\n              owner: context.repo.owner,\n              repo: context.repo.repo,\n              state: 'open',\n              labels: 'drift-detected'\n            });\n            const issueExists = issues.data.some(issue =&gt; issue.title === issueTitle);\n            if (!issueExists) {\n              await github.rest.issues.create({\n                owner: context.repo.owner,\n                repo: context.repo.repo,\n                title: issueTitle,\n                body: issueBody,\n                labels: ['drift-detected']\n              });\n            }\n\n  prod:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check Out Code\n        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n\n      - name: Configure OpenTofu\n        uses: opentofu/setup-opentofu@12f4debbf681675350b6cd1f0ff8ecfbda62027b # v1.0.4\n\n      - name: Print Tofu Version\n        run: tofu --version\n\n      - name: Get OIDC Token File\n        run: |\n          curl -s -H \"Authorization: bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN\" \"$ACTIONS_ID_TOKEN_REQUEST_URL&amp;audience=sts.amazonaws.com\" | jq -r .value &gt; /tmp/web-identity-token\n\n      - name: Tofu Init\n        run: tofu init --backend-config=\"key=${{ github.event.repository.name }}/prod/terraform.tfstate\" --var-file=\"prod.tfvars\"\n        working-directory: ${{ github.workspace }}/tofu\n\n      - name: Tofu Plan\n        id: plan-prod\n        run: tofu plan --var-file=\"prod.tfvars\" -no-color -detailed-exitcode -out=tfprod.plan\n        working-directory: ${{ github.workspace }}/tofu\n\n      - name: Create Issue if Drift Detected\n        if: steps.plan-prod.outputs.exitcode == 2\n        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1\n        with:\n          script: |\n            const fs = require('fs');\n            const { execSync } = require('child_process');\n\n            // Get the terraform plan output\n            const planOutput = execSync('tofu show -no-color tfprod.plan', {\n              cwd: 'tofu'\n            }).toString();\n\n            const plan = planOutput.length &gt; 65000 ? planOutput.substring(0, 65000) + \" ...\" : planOutput;\n\n            const truncateMessage = planOutput.length &gt; 65000 ? `&gt; [!NOTE]\\n&gt; The plan output is too long so it has been truncated. You can view the full plan at: ${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}` : \"\";\n\n            const issueTitle = 'Drift detected in PROD';\n            const issueBody = `# Drift has been detected in \\`prod\\`.\\nBelow is the plan output:\\n&lt;details&gt;&lt;summary&gt;Show Plan&lt;/summary&gt;\\n\\n\\`\\`\\`hcl\\n${plan}\\n\\`\\`\\`\\n&lt;/details&gt;\\n\\n${truncateMessage}`;\n            const issues = await github.rest.issues.listForRepo({\n              owner: context.repo.owner,\n              repo: context.repo.repo,\n              state: 'open',\n              labels: 'drift-detected'\n            });\n            const issueExists = issues.data.some(issue =&gt; issue.title === issueTitle);\n            if (!issueExists) {\n              await github.rest.issues.create({\n                owner: context.repo.owner,\n                repo: context.repo.repo,\n                title: issueTitle,\n                body: issueBody,\n                labels: ['drift-detected']\n              });\n            }\n</code></pre>"},{"location":"github_action_workflows/drift_check/#configuration","title":"Configuration","text":"<p>This workflow runs every day at 5pm UTC time. This is configured using a <code>cron schedule</code>. Additionally, it uses the <code>workflow_dispatch: {}</code> keyword which allows the manual triggering of a workflow:</p> .github/workflows/drift_check.yml<pre><code>on:\n  schedule:\n    - cron: '0 17 * * *' #5pm every day\n  workflow_dispatch: {}\n</code></pre> <p>This workflow needs permissions to:</p> <ol> <li>Create GitHub Issues</li> <li>Get the OIDC JWT Token to authenticate with AWS<ol> <li>So OpenTofu can run a <code>tofu plan</code></li> </ol> </li> <li>Checkout the base branch.</li> </ol> .github/workflows/drift_check.yml<pre><code>permissions:\n  issues: write\n  contents: read\n  id-token: write\n</code></pre> <p>Info</p> <p>As all jobs need this permission, we defined it at the root of the workflow to avoid repeating for each job.</p>"},{"location":"github_action_workflows/drift_check/#jobs","title":"Jobs","text":"<p>This workflow has two jobs:</p> <ol> <li><code>dev</code></li> <li><code>prod</code></li> </ol>"},{"location":"github_action_workflows/drift_check/#dev","title":"dev","text":".github/workflows/drift_check.yml<pre><code>dev:\n  runs-on: ubuntu-latest\n  steps:\n    - name: Check Out Code\n      uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n\n    - name: Configure OpenTofu\n      uses: opentofu/setup-opentofu@12f4debbf681675350b6cd1f0ff8ecfbda62027b # v1.0.4\n\n    - name: Print Tofu Version\n      run: tofu --version\n\n    - name: Get OIDC Token File\n      run: |\n        curl -s -H \"Authorization: bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN\" \"$ACTIONS_ID_TOKEN_REQUEST_URL&amp;audience=sts.amazonaws.com\" | jq -r .value &gt; /tmp/web-identity-token\n\n    - name: Tofu Init\n      run: tofu init --backend-config=\"key=${{ github.event.repository.name }}/dev/terraform.tfstate\" --var-file=\"dev.tfvars\"\n      working-directory: ${{ github.workspace }}/tofu\n\n    - name: Tofu Plan\n      id: plan-dev\n      run: tofu plan --var-file=\"dev.tfvars\" -no-color -detailed-exitcode -out=tfdev.plan\n      working-directory: ${{ github.workspace }}/tofu\n\n    - name: Create Issue if Drift Detected\n      if: steps.plan-dev.outputs.exitcode == 2\n      uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1\n      with:\n        script: |\n          const fs = require('fs');\n          const { execSync } = require('child_process');\n\n          // Get the terraform plan output\n          const planOutput = execSync('tofu show -no-color tfdev.plan', {\n            cwd: 'tofu'\n          }).toString();\n\n          const plan = planOutput.length &gt; 65000 ? planOutput.substring(0, 65000) + \" ...\" : planOutput;\n\n          const truncateMessage = planOutput.length &gt; 65000 ? `&gt; [!NOTE]\\n&gt; The plan output is too long so it has been truncated. You can view the full plan at: ${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}` : \"\";\n\n          const issueTitle = 'Drift detected in DEV';\n          const issueBody = `# Drift has been detected in \\`dev\\`.\\nBelow is the plan output:\\n&lt;details&gt;&lt;summary&gt;Show Plan&lt;/summary&gt;\\n\\n\\`\\`\\`hcl\\n${plan}\\n\\`\\`\\`\\n&lt;/details&gt;\\n\\n${truncateMessage}`;\n          const issues = await github.rest.issues.listForRepo({\n            owner: context.repo.owner,\n            repo: context.repo.repo,\n            state: 'open',\n            labels: 'drift-detected'\n          });\n          const issueExists = issues.data.some(issue =&gt; issue.title === issueTitle);\n          if (!issueExists) {\n            await github.rest.issues.create({\n              owner: context.repo.owner,\n              repo: context.repo.repo,\n              title: issueTitle,\n              body: issueBody,\n              labels: ['drift-detected']\n            });\n          }\n</code></pre> <p>This job:</p> <ol> <li>Checks out base branch</li> <li>Configures/Install OpenTofu</li> <li>Log the current OpenTofu version being used<ol> <li>This would be the latest version at the given time</li> </ol> </li> <li>Get the OIDC JWT to authenticate with AWS</li> <li>Initialise OpenTofu to download the <code>required_providers</code> in <code>provider.tf</code></li> <li>Run an OpenTofu Plan</li> <li>Create a GitHub Issue if drift has been detected.</li> </ol> <p>You might be thinking: \"how are we detecting drift?\" This is using the <code>-detailed-exitcode</code> flag of <code>tofu plan</code>. The exit code changes based on certain criteria:</p> <p>Quote (from opentofu.org)</p> <p>Returns a detailed exit code when the command exits. When provided, this argument changes the exit codes and their meanings to provide more granular information about what the resulting plan contains:</p> <ul> <li>0 = Succeeded with empty diff (no changes)</li> <li>1 = Error</li> <li>2 = Succeeded with non-empty diff (changes present)</li> </ul> <p>As we're using the official OpenTofu action that puts a wrapper around OpenTofu, we can use the exit code output from the Action to determine if we should create an issue or not. We use <code>2</code> which indicates changes are present and therefore drift so we need to create a GitHub Issue. </p> <p>You can see an example below: </p> <p></p> <p>Presenting the Plan and the Plan Size</p> <p>I explained the rationale for this in the Tofu Plan page, but it is relevant here as well. We output a plan file using the <code>-out</code> parameter of the <code>tofu plan</code> command, then we use <code>tofu show -no-color</code> to present it ready for outputting in the issue. My JavaScript isn't the best, so I found a useful workflow by GitHub user: tmlye that used the <code>execSync</code> function in JavaScript: https://github.com/actions/runner/issues/1733#issuecomment-2447036317. Here is where I hit my second issue, which if you looked at the title of the Issue in that comment will give you a little clue... \"Argument list too long\".</p> <p>If you have a massive plan output, which doesn't necessarily mean a mass amount of resources, but one that returns a big object, such as the <code>data \"http\" \"get\" {}</code> data source using the HTTP provider, you could easily hit this limit. I hit it myself when using the exact same data source to check Grafana application availability using a <code>check</code> block.</p> <p>I found an Issue online in which people came together to come up with a good solution to this problem. You can read more here: https://github.com/actions/github-script/issues/266. In short, we need to truncate the plan output:</p> .github/workflows/drift_check.yml<pre><code>const fs = require('fs');\nconst { execSync } = require('child_process');\n\n// Get the terraform plan output\nconst planOutput = execSync('tofu show -no-color tfdev.plan', {\n cwd: 'tofu'\n}).toString();\n\nconst plan = planOutput.length &gt; 65000 ? planOutput.substring(0, 65000) + \" ...\" : planOutput;\n\nconst truncateMessage = planOutput.length &gt; 65000 ? `&gt; [!NOTE]\\n&gt; The plan output is too long so it has been truncated. You can view the full plan at: ${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}` : \"\";\n\nconst issueTitle = 'Drift detected in DEV';\nconst issueBody = `# Drift has been detected in \\`dev\\`.\\nBelow is the plan output:\\n&lt;details&gt;&lt;summary&gt;Show Plan&lt;/summary&gt;\\n\\n\\`\\`\\`hcl\\n${plan}\\n\\`\\`\\`\\n&lt;/details&gt;\\n\\n${truncateMessage}`;\n</code></pre> <p>We convert the plan file into a string, and then use the <code>substring</code> function to take 65000 characters and append a <code>...</code>. If the plan file isn't more than 65000 characters long, we just use the full plan file. Using newer features in GitHub, we create a \"Note\" admonition to alert the user that the plan has been truncated and they can view the full plan at the link created by the issue. This uses a concatenation of multiple <code>context</code> variables to dynamically create it.</p> <p>You may also see that we use <code>-no-color</code> when using <code>tofu show</code>. This is because the \"color\" output is converted to the unicode equivalent, making the plan essentially unreadable. To add this back in, we use the <code>hcl</code> code identifier in the code block quote. I personally prefer seeing a colour output anyway and I imagine others do too!</p> <p>Lastly, we use the <code>&lt;details&gt;</code> and <code>&lt;summary&gt;</code> tags which makes the plan output collapsible in the pull request. I actually prefer this because if you have a massive plan output, it makes the PR/Issue look all cluttered - especially if multiple are ran and your original comment in not updated! You can see this in the screenshot taken above where it says <code>&gt; Show Plan</code>.</p> <p>These improvements have also made there way to the generic Tofu Plan reusable workflow documented here.</p>"},{"location":"github_action_workflows/drift_check/#prod","title":"prod","text":".github/workflows/drift_check.yml<pre><code>prod:\n  runs-on: ubuntu-latest\n  steps:\n    - name: Check Out Code\n      uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n\n    - name: Configure OpenTofu\n      uses: opentofu/setup-opentofu@12f4debbf681675350b6cd1f0ff8ecfbda62027b # v1.0.4\n\n    - name: Print Tofu Version\n      run: tofu --version\n\n    - name: Get OIDC Token File\n      run: |\n        curl -s -H \"Authorization: bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN\" \"$ACTIONS_ID_TOKEN_REQUEST_URL&amp;audience=sts.amazonaws.com\" | jq -r .value &gt; /tmp/web-identity-token\n\n    - name: Tofu Init\n      run: tofu init --backend-config=\"key=${{ github.event.repository.name }}/prod/terraform.tfstate\" --var-file=\"prod.tfvars\"\n      working-directory: ${{ github.workspace }}/tofu\n\n    - name: Tofu Plan\n      id: plan-prod\n      run: tofu plan --var-file=\"prod.tfvars\" -no-color -detailed-exitcode -out=tfprod.plan\n      working-directory: ${{ github.workspace }}/tofu\n\n    - name: Create Issue if Drift Detected\n      if: steps.plan-prod.outputs.exitcode == 2\n      uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1\n      with:\n        script: |\n          const fs = require('fs');\n          const { execSync } = require('child_process');\n\n          // Get the terraform plan output\n          const planOutput = execSync('tofu show -no-color tfprod.plan', {\n            cwd: 'tofu'\n          }).toString();\n\n          const plan = planOutput.length &gt; 65000 ? planOutput.substring(0, 65000) + \" ...\" : planOutput;\n\n          const truncateMessage = planOutput.length &gt; 65000 ? `&gt; [!NOTE]\\n&gt; The plan output is too long so it has been truncated. You can view the full plan at: ${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}` : \"\";\n\n          const issueTitle = 'Drift detected in PROD';\n          const issueBody = `# Drift has been detected in \\`prod\\`.\\nBelow is the plan output:\\n&lt;details&gt;&lt;summary&gt;Show Plan&lt;/summary&gt;\\n\\n\\`\\`\\`hcl\\n${plan}\\n\\`\\`\\`\\n&lt;/details&gt;\\n\\n${truncateMessage}`;\n          const issues = await github.rest.issues.listForRepo({\n            owner: context.repo.owner,\n            repo: context.repo.repo,\n            state: 'open',\n            labels: 'drift-detected'\n          });\n          const issueExists = issues.data.some(issue =&gt; issue.title === issueTitle);\n          if (!issueExists) {\n            await github.rest.issues.create({\n              owner: context.repo.owner,\n              repo: context.repo.repo,\n              title: issueTitle,\n              body: issueBody,\n              labels: ['drift-detected']\n            });\n          }\n</code></pre> <p>This is basically the same as <code>dev</code> - just changing which plan file to take an output of </p> <p>You can see the issue it creates on GitHub below:</p> <p></p>"},{"location":"github_action_workflows/infracost/","title":"Infracost","text":"<p>The Infracost job in the PR workflow checks how much the PR itself is going to cost. The workflow is just a job directly in the PR workflow. It also uses a Rego policy that is evaluated by the Open Policy Agent that checks if the PR will cost $10 or more, if it does it will fail the policy!</p> <p>Note</p> <p>Normally I would put this in it's own workflow and make it reusable, I designed it this way so you could see how flexible GitHub Actions can be! You don't have to use reusable workflows, but in general I recommend doing so as we can all contribute towards a common codebase and everyone then leverages the benefits.</p>"},{"location":"github_action_workflows/infracost/#workflow","title":"Workflow","text":".github/workflows/pr.yml<pre><code>infracost:\n  runs-on: ubuntu-latest\n  permissions:\n    contents: read\n    pull-requests: write\n  steps:\n    - name: Setup Infracost\n      uses: infracost/actions/setup@e9d6e6cd65e168e76b0de50ff9957d2fe8bb1832 # v3.0.1\n      with:\n        api-key: ${{ secrets.INFRACOST_API_KEY }}\n\n    - name: Checkout base branch\n      uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n      with:\n        ref: '${{ github.event.pull_request.base.ref }}'\n\n    - name: Generate Infracost cost estimate baseline\n      run: |\n        infracost breakdown --path=. \\\n                            --format=json \\\n                            --out-file=/tmp/infracost-base.json \\\n                            --terraform-var-file \"${{ github.base_ref == 'main' &amp;&amp; 'prod' || 'dev' }}.tfvars\"\n      working-directory: ${{ github.workspace }}/tofu\n\n    # Checkout the current PR branch so we can create a diff.\n    - name: Checkout PR branch\n      uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n\n    # Generate an Infracost diff and save it to a JSON file.\n    - name: Generate Infracost diff\n      run: |\n        infracost diff --path=. \\\n                        --format=json \\\n                        --compare-to=/tmp/infracost-base.json \\\n                        --out-file=/tmp/infracost.json \\\n                        --terraform-var-file \"${{ github.base_ref == 'main' &amp;&amp; 'prod' || 'dev' }}.tfvars\"\n      working-directory: ${{ github.workspace }}/tofu\n\n    - name: Post Infracost comment\n      run: |\n          infracost comment github --path=/tmp/infracost.json \\\n                                    --repo=$GITHUB_REPOSITORY \\\n                                    --github-token=${{ github.token }} \\\n                                    --pull-request=${{ github.event.pull_request.number }} \\\n                                    --behavior=update \\\n                                    --policy-path ./policies/cost.rego\n</code></pre>"},{"location":"github_action_workflows/infracost/#configuration","title":"Configuration","text":"<p>This job requires additional permissions, as it places a comment on the PR we need to give it <code>write</code> permissions on <code>pull-requests</code> and <code>read</code> permissions on <code>contents</code> so it can checkout the base branch AND the PR branch. This is important so it can make a cost comparison!</p> <p>Additionally, this is the first and only workflow that is making use of GitHub Action Secrets! In order for us to authenticate to the Infracost API, we need an API key. We store this in a secret named <code>INFRACOST_API_KEY</code> which is then passed to the workflow at runtime and is masked in any logs.</p>"},{"location":"github_action_workflows/infracost/#steps","title":"Steps","text":"<p>This job has 6 steps:</p> <ol> <li>Setup Infracost</li> <li>Checkout base branch</li> <li>Generate Infracost cost estimate baseline</li> <li>Checkout PR branch</li> <li>Generate Infracost diff</li> <li>Post Infracost comment</li> </ol>"},{"location":"github_action_workflows/infracost/#setup-infracost","title":"Setup Infracost","text":".github/workflows/pr.yml<pre><code>- name: Setup Infracost\n  uses: infracost/actions/setup@e9d6e6cd65e168e76b0de50ff9957d2fe8bb1832 # v3.0.1\n  with:\n    api-key: ${{ secrets.INFRACOST_API_KEY }}\n</code></pre> <p>We start by configuring and installing Infracost using their official GitHub Action. We pass in our API key that authenticates us with the API.</p>"},{"location":"github_action_workflows/infracost/#checkout-base-branch","title":"Checkout base branch","text":".github/workflows/pr.yml<pre><code>- name: Checkout base branch\n  uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n  with:\n    ref: '${{ github.event.pull_request.base.ref }}'\n</code></pre> <p>Infracost has to make a comparison with what is existing somewhere, as a result it checkouts the base (target) branch of the repository to know what is existing today.</p>"},{"location":"github_action_workflows/infracost/#generate-infracost-cost-estimate-baseline","title":"Generate Infracost cost estimate baseline","text":".github/workflows/pr.yml<pre><code>- name: Generate Infracost cost estimate baseline\n  run: |\n    infracost breakdown --path=. \\\n                        --format=json \\\n                        --out-file=/tmp/infracost-base.json \\\n                        --terraform-var-file \"${{ github.base_ref == 'main' &amp;&amp; 'prod' || 'dev' }}.tfvars\"\n  working-directory: ${{ github.workspace }}/tofu\n</code></pre> <p>Once the base branch has been checked out, it then breaks it down in a format to use as a comparison later. As we pass in the <code>working-directory</code> directive, <code>.</code> translates to the <code>tofu/</code> directory where the configuration is stored in the repo via the <code>--path</code> flag. As we specify the volume size and instance type as part our variables, we pass in the var file to infracost so it generates an accurate breakdown.</p>"},{"location":"github_action_workflows/infracost/#checkout-pr-branch","title":"Checkout PR branch","text":".github/workflows/pr.yml<pre><code>- name: Checkout PR branch\n  uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n</code></pre> <p>Simply put, it checkouts the PR branch to learn about what changes are being made.</p>"},{"location":"github_action_workflows/infracost/#generate-infracost-diff","title":"Generate Infracost diff","text":".github/workflows/pr.yml<pre><code>- name: Generate Infracost diff\nrun: |\n  infracost diff --path=. \\\n                  --format=json \\\n                  --compare-to=/tmp/infracost-base.json \\\n                  --out-file=/tmp/infracost.json \\\n                  --terraform-var-file \"${{ github.base_ref == 'main' &amp;&amp; 'prod' || 'dev' }}.tfvars\"\nworking-directory: ${{ github.workspace }}/tofu\n</code></pre> <p>Now it has context of the two branches, it used the breakdown it generated in the 3rd step and compares it against the PR to generate the cost of any changes made.</p>"},{"location":"github_action_workflows/infracost/#post-infracost-comment","title":"Post Infracost comment","text":".github/workflows/pr.yml<pre><code>- name: Post Infracost comment\n  run: |\n      infracost comment github --path=/tmp/infracost.json \\\n                                --repo=$GITHUB_REPOSITORY \\\n                                --github-token=${{ github.token }} \\\n                                --pull-request=${{ github.event.pull_request.number }} \\\n                                --behavior=update \\\n                                --policy-path ./policies/cost.rego\n</code></pre> <p>Before it posts the comment on GitHub as part of the PR. It uses Open Policy Agent integration to ensure the cost complies with any OPA policies we tell Infracost to compare against. The policy that we are telling infracost to use is:</p> policies/cost.rego<pre><code>package infracost # You must specify infracost as the Rego package name\n\n# Each file can have a number of \"deny\" rules that must return an \"out\" object\n# with keys \"msg\" &amp; \"failed\". You can write as many \"deny[out]\" rule sets as you wish. \n# You can read more about rule definitions in Rego here: https://www.openpolicyagent.org/docs/latest/policy-language/#rules\ndeny[out] {\n  # maxDiff defines the threshold that you require the cost estimate to be below\n  maxDiff = 10.0\n\n  # msg defines the output that will be shown in PR comments under the Policy Checks/Failures section\n  msg := sprintf(\n    \"Total monthly cost diff must be less than $%.2f (actual diff is $%.2f)\",\n    [maxDiff, to_number(input.diffTotalMonthlyCost)],\n  )\n\n  # out defines the output for this policy. This output must be formatted with a `msg` and `failed` property.\n  out := {\n    # the msg you want to display in your PR comment, must be a string\n    \"msg\": msg,\n    # a boolean value that determines if this policy has failed.\n    # In this case if the Infracost breakdown output diffTotalMonthlyCost is greater that $5000\n    \"failed\": to_number(input.diffTotalMonthlyCost) &gt;= maxDiff\n  }\n}\n</code></pre> <p>The output is then posted as a comment on the PR, if any changes are made, it then updates the existing comment!</p> <p>You can see an example below:</p> <p></p> <p></p>"},{"location":"github_action_workflows/linters/","title":"Linter Checks","text":"<p>This workflow is called by the <code>pr.yml</code> workflow to run linter checks against code in each PR. The linters in use are:</p> <ol> <li>markdownlint</li> <li>tflint</li> <li>cspell</li> </ol> <p>Note</p> <p>This page covers the GitHub Action Workflow and not the tool itself. If you are interested in the tool itself, you can go to the links above, or visit: Toolchain, where I talk about the toolchain used in this project.</p>"},{"location":"github_action_workflows/linters/#calling-workflow","title":"Calling Workflow","text":".github/workflows/pr.yml<pre><code>linters:\n  permissions:\n    contents: read\n    id-token: write\n    pull-requests: write\n  uses: ./.github/workflows/linters.yml\n</code></pre>"},{"location":"github_action_workflows/linters/#workflow","title":"Workflow","text":".github/workflows/linters.yml<pre><code>name: linter_checks\non:\n  workflow_call:\njobs:\n  markdownlint:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check Out Code\n        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n\n      - name: Run Markdownlint\n        uses: DavidAnson/markdownlint-cli2-action@db43aef879112c3119a410d69f66701e0d530809 # v17.0.0\n\n  tflint:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check Out Code\n        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n\n      - name: Setup TFLint\n        uses: terraform-linters/setup-tflint@19a52fbac37dacb22a09518e4ef6ee234f2d4987 # v4.0.0\n        with:\n          tflint_version: latest\n\n      - name: Print TFLint Version\n        run: tflint --version\n\n      - name: Init TFLint\n        run: tflint --init\n        env:\n          # https://github.com/terraform-linters/tflint/blob/master/docs/user-guide/plugins.md#avoiding-rate-limiting\n          GITHUB_TOKEN: ${{ github.token }}\n\n      - name: Run TFLint\n        run: tflint --chdir=.\n        working-directory: ${{ github.workspace }}/tofu\n\n  cspell:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check Out Code\n        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n        with:\n          ref: ${{ github.event.pull_request.head.ref }}\n\n      - name: Run cspell\n        uses: streetsidesoftware/cspell-action@9759be9ad475fe8145f8d2a1bf29a1c4d1c6f18d # v6.9.0\n        with:\n          files: .*/**/*.md\n          config: .cspell.yml\n\n  post-comment:\n    runs-on: ubuntu-latest\n    needs: [markdownlint, tflint, cspell]\n    steps:\n      - name: Post Comment\n        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1\n        with:\n          script: |\n            const markdownlintResult = `**Markdownlint:** ${{ needs.markdownlint.result }}`;\n            const tflintResult = `**TFLint:** ${{ needs.tflint.result }}`;\n            const cspellResult = `**cspell:** ${{ needs.cspell.result }}`;\n            const commentBody = `## Linter Checks Result\\n\\n${markdownlintResult}\\n${tflintResult}\\n${cspellResult}`;\n\n            const { data: comments } = await github.rest.issues.listComments({\n              owner: context.repo.owner,\n              repo: context.repo.repo,\n              issue_number: context.issue.number,\n            });\n\n            const botComment = comments.find(comment =&gt; comment.user.login === 'github-actions[bot]' &amp;&amp; comment.body.includes(\"## Linter Checks Result\"));\n\n            if (!botComment) {\n              await github.rest.issues.createComment({\n                owner: context.repo.owner,\n                repo: context.repo.repo,\n                issue_number: context.issue.number,\n                body: commentBody,\n              });\n            } else {\n              await github.rest.issues.updateComment({\n                owner: context.repo.owner,\n                repo: context.repo.repo,\n                comment_id: botComment.id,\n                body: commentBody,\n              });\n            }\n</code></pre>"},{"location":"github_action_workflows/linters/#configuration","title":"Configuration","text":"<p>This workflow is reusable, denoted by the <code>workflow_call</code> directive in the workflow and has no inputs.</p> <p>It requires three different permissions which are granted from the caller workflow:</p> <ol> <li>To get the PR branch (<code>contents: read</code>)</li> <li>To initialise OpenTofu, therefore needing to authenticate with AWS using the deployment role (<code>id-token: write</code>)</li> <li>Post a comment of the results of the checks to the PR (<code>pull-requests: write</code>)</li> </ol> .github/workflows/pr.yml<pre><code>permissions:\n  contents: read\n  id-token: write\n  pull-requests: write\n</code></pre>"},{"location":"github_action_workflows/linters/#jobs","title":"Jobs","text":"<p>This workflow has 4 jobs:</p> <ol> <li>markdownlint</li> <li>tflint</li> <li>cspell</li> <li>post-comment</li> </ol>"},{"location":"github_action_workflows/linters/#markdownlint","title":"markdownlint","text":".github/workflows/linters.yml<pre><code>markdownlint:\n  runs-on: ubuntu-latest\n  steps:\n    - name: Check Out Code\n      uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n\n    - name: Run Markdownlint\n      uses: DavidAnson/markdownlint-cli2-action@db43aef879112c3119a410d69f66701e0d530809 # v17.0.0\n</code></pre> <p>This job simply runs the markdownlint cli action from the author of markdownlint.</p>"},{"location":"github_action_workflows/linters/#tflint","title":"tflint","text":".github/workflows/linters.yml<pre><code>tflint:\n  runs-on: ubuntu-latest\n  steps:\n    - name: Check Out Code\n      uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n\n    - name: Setup TFLint\n      uses: terraform-linters/setup-tflint@19a52fbac37dacb22a09518e4ef6ee234f2d4987 # v4.0.0\n      with:\n        tflint_version: latest\n\n    - name: Print TFLint Version\n      run: tflint --version\n\n    - name: Init TFLint\n      run: tflint --init\n      env:\n        # https://github.com/terraform-linters/tflint/blob/master/docs/user-guide/plugins.md#avoiding-rate-limiting\n        GITHUB_TOKEN: ${{ github.token }}\n\n    - name: Run TFLint\n      run: tflint --chdir=.\n      working-directory: ${{ github.workspace }}/tofu\n</code></pre> <p><code>tflint</code> uses the official action from the authors which installs the tool, following which we use normal CLI commands to run it as you would in your local terminal. The <code>env</code> variable here is to use the token of the runner to make an authenticated request to the GitHub APIs as tflint does its initialisation process. While you can make unauthenticated requests, you will eventually be rate limited.</p> <p>Lastly we just tell tflint to run inside the <code>tofu</code> directory where it needs to run.</p>"},{"location":"github_action_workflows/linters/#cspell","title":"cspell","text":".github/workflows/linters.yml<pre><code>cspell:\n  runs-on: ubuntu-latest\n  steps:\n    - name: Check Out Code\n      uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n      with:\n        ref: ${{ github.event.pull_request.head.ref }}\n\n    - name: Run cspell\n      uses: streetsidesoftware/cspell-action@9759be9ad475fe8145f8d2a1bf29a1c4d1c6f18d # v6.9.0\n      with:\n        files: .*/**/*.md\n        config: .cspell.yml\n</code></pre> <p>Using the official action from the cspell authors, we tell it to look for all markdown files. Following which we pass in a config file located at the root of the repo to configure additional behaviour.</p> <p>Note</p> <p>To learn more about the config you can visit the Toolchain page. We could configure custom dictionaries for this tool as well, however having used the tool in the past a lot of the functions in Terraform are flagged. To keep it simple, I scoped this tool to look at markdown files only.</p>"},{"location":"github_action_workflows/linters/#post-comment","title":"post-comment","text":".github/workflows/linters.yml<pre><code>post-comment:\n  runs-on: ubuntu-latest\n  needs: [markdownlint, tflint, cspell]\n  steps:\n    - name: Post Comment\n      uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1\n      with:\n        script: |\n          const markdownlintResult = `**Markdownlint:** ${{ needs.markdownlint.result }}`;\n          const tflintResult = `**TFLint:** ${{ needs.tflint.result }}`;\n          const cspellResult = `**cspell:** ${{ needs.cspell.result }}`;\n          const commentBody = `## Linter Checks Result\\n\\n${markdownlintResult}\\n${tflintResult}\\n${cspellResult}`;\n\n          const { data: comments } = await github.rest.issues.listComments({\n            owner: context.repo.owner,\n            repo: context.repo.repo,\n            issue_number: context.issue.number,\n          });\n\n          const botComment = comments.find(comment =&gt; comment.user.login === 'github-actions[bot]' &amp;&amp; comment.body.includes(\"## Linter Checks Result\"));\n\n          if (!botComment) {\n            await github.rest.issues.createComment({\n              owner: context.repo.owner,\n              repo: context.repo.repo,\n              issue_number: context.issue.number,\n              body: commentBody,\n            });\n          } else {\n            await github.rest.issues.updateComment({\n              owner: context.repo.owner,\n              repo: context.repo.repo,\n              comment_id: botComment.id,\n              body: commentBody,\n            });\n          }\n</code></pre> <p>Like other Actions I have authored, we use the <code>github-script</code> action to take the results of previous jobs, and then output that as a comment on the PR confirming success or failure. If a comment already exists, then it simply updates as opposed to creating a new one and cluttering up the PR.</p>"},{"location":"github_action_workflows/mkdocs/","title":"MkDocs (Material)","text":"<p>This workflow deploys the documentation using \"Material for Mkdocs\" into GitHub Pages.</p>"},{"location":"github_action_workflows/mkdocs/#workflow","title":"Workflow","text":".github/workflows/mkdocs.yml<pre><code>name: Generate Documentation\non:\n  push:\n    branches:\n      - main\n    paths:\n      - 'docs/**'\n      - 'mkdocs.yml'\npermissions:\n  contents: write\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check Out Code\n        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n\n      - name: Configure Git Credentials\n        run: |\n          git config user.name github-actions[bot]\n          git config user.email 41898282+github-actions[bot]@users.noreply.github.com\n\n      - name: Setup Python\n        uses: actions/setup-python@0b93645e9fea7318ecaed2b359559ac225c90a2b # v5.3.0\n        with:\n          python-version: 3.x\n\n      - name: Generate Cache ID\n        run: echo \"cache_id=$(date --utc '+%V')\" &gt;&gt; $GITHUB_ENV\n        shell: bash\n\n      - uses: actions/cache@6849a6489940f00c2f30c0fb92c6274307ccb58a # v4.1.2\n        with:\n          key: mkdocs-material-${{ env.cache_id }}\n          path: .cache\n          restore-keys: |\n            mkdocs-material-\n\n      - name: Run Mkdocs Material\n        run: pip install mkdocs-material\n\n      - name: Deploy Mkdocs\n        run: mkdocs gh-deploy --force\n</code></pre>"},{"location":"github_action_workflows/mkdocs/#configuration","title":"Configuration","text":"<p>This workflow triggers based on the <code>push</code> to the <code>main</code> branch, but only if any file within the <code>docs/</code> directory or <code>mkdocs.yml</code> is updated.</p> <p>It also needs permission to publish to GitHub Actions, therefore we use the <code>contents: write</code> permission to grant it so. This deploys the documentation to a branch called <code>gh-pages</code> which the GitHub Pages configuration has been configured to listen too.</p>"},{"location":"github_action_workflows/mkdocs/#jobs","title":"Jobs","text":"<p>This workflow only has one job:</p> <ol> <li>deploy</li> </ol>"},{"location":"github_action_workflows/mkdocs/#deploy","title":"deploy","text":".github/workflows/mkdocs.yml<pre><code>deploy:\n  runs-on: ubuntu-latest\n  steps:\n    - name: Check Out Code\n      uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n\n    - name: Configure Git Credentials\n      run: |\n        git config user.name github-actions[bot]\n        git config user.email 41898282+github-actions[bot]@users.noreply.github.com\n\n    - name: Setup Python\n      uses: actions/setup-python@0b93645e9fea7318ecaed2b359559ac225c90a2b # v5.3.0\n      with:\n        python-version: 3.x\n\n    - name: Generate Cache ID\n      run: echo \"cache_id=$(date --utc '+%V')\" &gt;&gt; $GITHUB_ENV\n      shell: bash\n\n    - uses: actions/cache@6849a6489940f00c2f30c0fb92c6274307ccb58a # v4.1.2\n      with:\n        key: mkdocs-material-${{ env.cache_id }}\n        path: .cache\n        restore-keys: |\n          mkdocs-material-\n\n    - name: Run Mkdocs Material\n      run: pip install mkdocs-material\n\n    - name: Deploy Mkdocs\n      run: mkdocs gh-deploy --force\n</code></pre> <p>This job clones the repo and configures the latest Python 3 version available at runtime. This is because Material for Mkdocs is managed as a package using Python's package manager <code>pip</code>. A cache is then generated and <code>mkdocs-material</code> is installed. Lastly, it is deployed to the <code>gh-deploy</code> branch.</p>"},{"location":"github_action_workflows/port_check/","title":"Port Check","text":"<p>This workflow is used to check port availability of the Grafana instances in the <code>dev</code> and <code>prod</code> environments. It does a simple <code>curl</code> check to see if it can be accessed and if not, creates a GitHub Issue inside the repo.</p>"},{"location":"github_action_workflows/port_check/#workflow","title":"Workflow","text":".github/workflows/port_check.yml<pre><code>name: Port Check\n\non:\n  schedule:\n    - cron: '0 17 * * *'\n  workflow_dispatch: {}\n\npermissions:\n  issues: write\n\njobs:\n  dev:\n    runs-on: ubuntu-latest\n    steps:\n    - name: Check port availability\n      run: |\n        IP_ADDRESS=\"35.178.137.32\"\n        PORT=\"3000\"\n        echo IP_ADDRESS_DEV=\"35.178.137.32\" &gt;&gt; $GITHUB_ENV\n        echo PORT=\"3000\" &gt;&gt; $GITHUB_ENV\n\n        if curl --silent --fail --max-time 20 --connect-timeout 10 \"http://$IP_ADDRESS:$PORT\"; then\n          echo \"Grafana is available in dev!\"\n        else\n          echo \"Grafana is NOT AVAILABLE in DEV!\"\n          echo \"port_unavailable_dev=true\" &gt;&gt; $GITHUB_ENV\n        fi\n\n    - name: Create Issue if Grafana is not available\n      if: env.port_unavailable_dev == 'true'\n      uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1\n      with:\n        script: |\n          const issueTitle = 'Grafana Unavailable Alert in DEV';\n          const issueBody = `The port ${{ env.PORT }} at IP address ${{ env.IP_ADDRESS_DEV }} is not available. Please check the service.`;\n          const issues = await github.rest.issues.listForRepo({\n            owner: context.repo.owner,\n            repo: context.repo.repo,\n            state: 'open',\n            labels: 'port-check-failed'\n          });\n          const issueExists = issues.data.some(issue =&gt; issue.title === issueTitle);\n          if (!issueExists) {\n            await github.rest.issues.create({\n              owner: context.repo.owner,\n              repo: context.repo.repo,\n              title: issueTitle,\n              body: issueBody,\n              labels: ['port-check-failed']\n            });\n          }\n\n  prod:\n    runs-on: ubuntu-latest\n    steps:\n    - name: Check port availability\n      run: |\n        IP_ADDRESS=\"13.41.201.92\"\n        PORT=\"3000\"\n        echo IP_ADDRESS_PROD=\"13.41.201.92\" &gt;&gt; $GITHUB_ENV\n        echo PORT=\"3000\" &gt;&gt; $GITHUB_ENV\n\n        if curl --silent --fail --max-time 20 --connect-timeout 10 \"http://$IP_ADDRESS:$PORT\"; then\n          echo \"Grafana is available in prod!\"\n        else\n          echo \"Grafana is NOT AVAILABLE in PROD!\"\n          echo \"port_unavailable_prod=true\" &gt;&gt; $GITHUB_ENV\n        fi\n\n\n    - name: Create Issue if Grafana is not available\n      if: env.port_unavailable_prod == 'true'\n      uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1\n      with:\n        script: |\n          const issueTitle = 'Grafana Unavailable Alert in PROD';\n          const issueBody = `The port ${{ env.PORT }} at IP address ${{ env.IP_ADDRESS_PROD }} is not available. Please check the service.`;\n          const issues = await github.rest.issues.listForRepo({\n            owner: context.repo.owner,\n            repo: context.repo.repo,\n            state: 'open',\n            labels: 'port-check-failed'\n          });\n          const issueExists = issues.data.some(issue =&gt; issue.title === issueTitle);\n          if (!issueExists) {\n            await github.rest.issues.create({\n              owner: context.repo.owner,\n              repo: context.repo.repo,\n              title: issueTitle,\n              body: issueBody,\n              labels: ['port-check-failed']\n            });\n          }\n</code></pre>"},{"location":"github_action_workflows/port_check/#configuration","title":"Configuration","text":"<p>This workflow runs every day at 5pm UTC time. This is configured using a <code>cron schedule</code>. Additionally, it uses the <code>workflow_dispatch: {}</code> keyword which allows the manual triggering of a workflow:</p> .github/workflows/port_check.yml<pre><code>on:\n  schedule:\n    - cron: '0 17 * * *'\n  workflow_dispatch: {}\n</code></pre> <p>As it requires access to create Issues, we grant it the <code>permissions.issues: write</code> permission.</p> .github/workflows/port_check.yml<pre><code>permissions:\n  issues: write\n</code></pre> <p>Info</p> <p>As all jobs need this permission, we defined it at the root of the workflow to avoid repeating for each job.</p>"},{"location":"github_action_workflows/port_check/#jobs","title":"Jobs","text":"<p>This workflow has two jobs:</p> <ol> <li><code>dev</code></li> <li><code>prod</code></li> </ol>"},{"location":"github_action_workflows/port_check/#dev","title":"dev","text":".github/workflows/port_check.yml<pre><code>dev:\n  runs-on: ubuntu-latest\n  steps:\n  - name: Check port availability\n    run: |\n      IP_ADDRESS=\"35.178.137.32\"\n      PORT=\"3000\"\n      echo IP_ADDRESS_DEV=\"35.178.137.32\" &gt;&gt; $GITHUB_ENV\n      echo PORT=\"3000\" &gt;&gt; $GITHUB_ENV\n\n      if curl --silent --fail --max-time 20 --connect-timeout 10 \"http://$IP_ADDRESS:$PORT\"; then\n        echo \"Grafana is available in dev!\"\n      else\n        echo \"Grafana is NOT AVAILABLE in DEV!\"\n        echo \"port_unavailable_dev=true\" &gt;&gt; $GITHUB_ENV\n      fi\n\n  - name: Create Issue if Grafana is not available\n    if: env.port_unavailable_dev == 'true'\n    uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1\n    with:\n      script: |\n        const issueTitle = 'Grafana Unavailable Alert in DEV';\n        const issueBody = `The port ${{ env.PORT }} at IP address ${{ env.IP_ADDRESS_DEV }} is not available. Please check the service.`;\n        const issues = await github.rest.issues.listForRepo({\n          owner: context.repo.owner,\n          repo: context.repo.repo,\n          state: 'open',\n          labels: 'port-check-failed'\n        });\n        const issueExists = issues.data.some(issue =&gt; issue.title === issueTitle);\n        if (!issueExists) {\n          await github.rest.issues.create({\n            owner: context.repo.owner,\n            repo: context.repo.repo,\n            title: issueTitle,\n            body: issueBody,\n            labels: ['port-check-failed']\n          });\n        }\n</code></pre> <p>The <code>$GITHUB_ENV</code> environment variable is used to pass variables too which can be later referenced in additional steps and their configurations. For example: <code>echo IP_ADDRESS=\"35.178.137.32\" &gt;&gt; $GITHUB_ENV</code> and using the <code>env</code> context: <code>env.port_unavailable_dev == 'true'</code> for the next step. </p> <p>This means the <code>Create Issue if Grafana is not available</code> step only runs if the <code>if</code> condition returns <code>true</code>. This step simply takes the IP Address and Port it tried to connect and create a GitHub Issue. It uses Javascript to call the REST API.</p>"},{"location":"github_action_workflows/port_check/#prod","title":"prod","text":".github/workflows/port_check.yml<pre><code>prod:\n  runs-on: ubuntu-latest\n  steps:\n  - name: Check port availability\n    run: |\n      IP_ADDRESS=\"13.41.201.92\"\n      PORT=\"3000\"\n      echo IP_ADDRESS_PROD=\"13.41.201.92\" &gt;&gt; $GITHUB_ENV\n      echo PORT=\"3000\" &gt;&gt; $GITHUB_ENV\n\n      if curl --silent --fail --max-time 20 --connect-timeout 10 \"http://$IP_ADDRESS:$PORT\"; then\n        echo \"Grafana is available in prod!\"\n      else\n        echo \"Grafana is NOT AVAILABLE in PROD!\"\n        echo \"port_unavailable_prod=true\" &gt;&gt; $GITHUB_ENV\n      fi\n\n\n  - name: Create Issue if Grafana is not available\n    if: env.port_unavailable_prod == 'true'\n    uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1\n    with:\n      script: |\n        const issueTitle = 'Grafana Unavailable Alert in PROD';\n        const issueBody = `The port ${{ env.PORT }} at IP address ${{ env.IP_ADDRESS_PROD }} is not available. Please check the service.`;\n        const issues = await github.rest.issues.listForRepo({\n          owner: context.repo.owner,\n          repo: context.repo.repo,\n          state: 'open',\n          labels: 'port-check-failed'\n        });\n        const issueExists = issues.data.some(issue =&gt; issue.title === issueTitle);\n        if (!issueExists) {\n          await github.rest.issues.create({\n            owner: context.repo.owner,\n            repo: context.repo.repo,\n            title: issueTitle,\n            body: issueBody,\n            labels: ['port-check-failed']\n          });\n        }\n</code></pre> <p>This is basically the same as <code>dev</code> with the IP address changing to reflect the production environment. If the IP and Port is not available, then it creates a GitHub Issue.</p> <p>You can see an example below:</p> <p></p>"},{"location":"github_action_workflows/pr/","title":"PR","text":"<p>This is the core workflow that orchestrates other reusable workflows to ensure all required checks run in each PR. This is a combination of:</p> <ul> <li>OpenTofu Format Checks (<code>tofu fmt</code>)</li> <li>OpenTofu Native Testing Checks (using <code>tofu test</code>)</li> <li>OpenTofu Validation Checks (<code>tofu validate</code>)</li> <li>OpenTofu Plan (<code>tofu plan</code>)</li> <li>Infracost</li> <li>SAST (Static Application Security Testing)<ul> <li>checkov</li> <li>Trivy</li> </ul> </li> <li>Linters<ul> <li>markdownlint</li> <li>tflint</li> </ul> </li> <li>terraform-docs</li> </ul> <p>Note</p> <p>You may notice OpenTofu Apply (<code>tofu apply</code>) hasn't been mentioned above. This is because this is done following a merge to the base branch using GitHub Environments!</p> <p>The workflow is presented below:</p> .github/workflows/pr.yml<pre><code>name: PR\n\non:\n  pull_request:\n    types: [opened, reopened, synchronize]\n    branches:\n      - dev\n      - main\n    paths:\n      - 'tofu/**'\n\npermissions:\n  contents: read\n\ndefaults:\n  run:\n    shell: bash\n\njobs:\n  tofu-checks:\n    permissions:\n      contents: read\n      id-token: write\n      pull-requests: write\n    uses: ./.github/workflows/tofu_checks.yml\n    with:\n      tf_var_file: \"${{ github.base_ref == 'main' &amp;&amp; 'prod' || 'dev' }}.tfvars\"\n\n  tofu-plan:\n    permissions:\n      contents: read\n      id-token: write\n      pull-requests: write\n    uses: ./.github/workflows/tofu_plan.yml\n    with:\n      environment: ${{ github.base_ref == 'main' &amp;&amp; 'prod' || 'dev' }}\n      tf_var_file: \"${{ github.base_ref == 'main' &amp;&amp; 'prod' || 'dev' }}.tfvars\"\n\n  sast-checks:\n    uses: ./.github/workflows/sast.yml\n\n  linters:\n    permissions:\n      contents: read\n      id-token: write\n      pull-requests: write\n    uses: ./.github/workflows/linters.yml\n\n  terraform-docs:\n    uses: ./.github/workflows/terraform_docs.yml\n    with:\n      config_file: \".terraform-docs.yml\"\n      directory: \"tofu\"\n      tfdoc_version: \"v0.19.0\"\n\n  infracost:\n    runs-on: ubuntu-latest\n    permissions:\n      contents: read\n      pull-requests: write\n    steps:\n      - name: Setup Infracost\n        uses: infracost/actions/setup@e9d6e6cd65e168e76b0de50ff9957d2fe8bb1832 # v3.0.1\n        with:\n          api-key: ${{ secrets.INFRACOST_API_KEY }}\n\n      - name: Checkout base branch\n        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n        with:\n          ref: '${{ github.event.pull_request.base.ref }}'\n\n      - name: Generate Infracost cost estimate baseline\n        run: |\n          infracost breakdown --path=. \\\n                              --format=json \\\n                              --out-file=/tmp/infracost-base.json \\\n                              --terraform-var-file \"${{ github.base_ref == 'main' &amp;&amp; 'prod' || 'dev' }}.tfvars\"\n        working-directory: ${{ github.workspace }}/tofu\n\n      # Checkout the current PR branch so we can create a diff.\n      - name: Checkout PR branch\n        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n\n      # Generate an Infracost diff and save it to a JSON file.\n      - name: Generate Infracost diff\n        run: |\n          infracost diff --path=. \\\n                          --format=json \\\n                          --compare-to=/tmp/infracost-base.json \\\n                          --out-file=/tmp/infracost.json \\\n                          --terraform-var-file \"${{ github.base_ref == 'main' &amp;&amp; 'prod' || 'dev' }}.tfvars\"\n        working-directory: ${{ github.workspace }}/tofu\n\n      - name: Post Infracost comment\n        run: |\n            infracost comment github --path=/tmp/infracost.json \\\n                                      --repo=$GITHUB_REPOSITORY \\\n                                      --github-token=${{ github.token }} \\\n                                      --pull-request=${{ github.event.pull_request.number }} \\\n                                      --behavior=update \\\n                                      --policy-path ./policies/cost.rego\n</code></pre>"},{"location":"github_action_workflows/pr/#configuration","title":"Configuration","text":"<p>As this is the first Action we're seeing. Lets breakdown some commonality you'll see amongst all workflows:</p> <p>Name</p> <pre><code>name: PR\n</code></pre> <p>Quite self explanatory - name of the GitHub Action.</p> <p>On</p> <pre><code>on:\n  pull_request:\n    types: [opened, reopened, synchronize]\n    branches:\n      - dev\n      - main\n    paths:\n      - 'tofu/**'\n</code></pre> <p>Without starting a fight on the right way of defining a list in <code>yaml</code> so I did both , this workflow only runs under the following conditions:</p> <ol> <li>Is a pull request</li> <li>Whether that pull request is <code>opened</code>, <code>reopened</code> or synchronised (<code>synchronize</code>)</li> <li>If the target branch is either <code>dev</code> or <code>main</code></li> <li>Only if the pull request has changes to anything inside the <code>tofu/</code> directory</li> </ol> <p>Info</p> <p>All of these conditions must be true before the Action will execute!</p> <p>Permissions</p> <pre><code>permissions:\n  contents: read\n</code></pre> <p><code>permissions</code> can be set at the workflow level and job level. With the job level taking precedence. This is a basic permissions, which gives the workflow permission to, say, use the <code>checkout</code> GitHub Action to pull the code down.</p> <p>Defaults</p> <pre><code>defaults:\n  run:\n    shell: bash\n</code></pre> <p><code>defaults</code> is used to set any default for all jobs and steps. In this case, it will ensure each step/command runs in the <code>bash</code> shell.</p>"},{"location":"github_action_workflows/pr/#jobs","title":"Jobs","text":"<pre><code># &lt;truncated&gt;\njobs:\n  tofu-checks:\n    permissions:\n      contents: read\n      id-token: write\n      pull-requests: write\n    uses: ./.github/workflows/tofu_checks.yml\n    with:\n      tf_var_file: \"${{ github.base_ref == 'main' &amp;&amp; 'prod' || 'dev' }}.tfvars\"\n# &lt;truncated&gt;\n</code></pre> <p>I won't go into too much detail about what jobs are and all the available arguments. You can find all that information out here: https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions#jobs.</p> <p>I will cover this first one, and then the rest of the document will follow the order of the PR workflow jobs covering each workflow and its intended purpose.</p> <p>Job ID</p> <p><code>tofu-checks</code> is the name of the specific job.</p> <p>Job Permissions</p> <p>This reusable action also requires additional permissions, so like I mentioned before I have specified permissions at the <code>job</code> level - which takes precedence.</p> <ol> <li><code>contents</code> is set at <code>read</code> so the PR can be checked out</li> <li><code>id-token</code> is set as <code>write</code> so the JWT (JSON Web Token using OIDC (OpenID Connect)) can be requested to authenticate with AWS (this action requires <code>tofu init</code> to be ran)</li> <li><code>pull-requests</code> is set as <code>write</code> as it will post a comment to the PR with status checks</li> </ol> <p>Warning</p> <p>I could technically place this at the root of the workflow, but that would mean ALL jobs would have these permissions. To adhere to the principal of least privilege, I'm only specifying additional permissions for each job that actually needs them!</p> <p>Uses</p> <p>The <code>uses</code> keyword points to another workflow (reusable) to run. It is defined at the following path: <code>./.github/workflows/tofu_checks.yml</code></p> <p>Info</p> <p>You might notice that a commit sha, or version is not specified. In this case, the workflow in GitHub Actions shows the following: <code>kieran-lowe/gitops-2024/.github/workflows/tofu_plan.yml@refs/pull/57/merge</code> - as this workflow is part of my repo anyway, I haven't specified anything:</p> <pre><code>uses: ./.github/workflows/tofu_checks.yml\n</code></pre> <p>With</p> <p>The <code>with</code> keywords allows you to pass in inputs to the reusable workflow, in this case <code>tf_var_file</code> which the <code>./.github/workflows/tofu_checks.yml</code> workflow expects.</p> <pre><code>with:\n  tf_var_file: \"${{ github.base_ref == 'main' &amp;&amp; 'prod' || 'dev' }}.tfvars\"\n</code></pre> <p>As there are two environments: <code>dev</code> and <code>prod</code> we use some conditional logic using the <code>github</code> context. The conditional works like this: <code>${{ condition &amp;&amp; is_truthy || is_false }}</code></p> <p>Now lets go into the jobs! We have 6 in total for this workflow:</p> <ol> <li>tofu-checks</li> <li>tofu-plan</li> <li>sast-checks</li> <li>linters</li> <li>terraform-docs</li> <li>infracost</li> </ol> <p>Note</p> <p>Each additional job/workflow has been documented in its own area to avoid making this page huge. The links for each are below!</p>"},{"location":"github_action_workflows/pr/#tofu-checks","title":"tofu-checks","text":"<ul> <li>Please visit: Tofu Checks</li> </ul>"},{"location":"github_action_workflows/pr/#tofu-plan","title":"tofu-plan","text":"<ul> <li>Please visit: Tofu Plan</li> </ul>"},{"location":"github_action_workflows/pr/#sast-checks","title":"sast-checks","text":"<ul> <li>Please visit: SAST Checks</li> </ul>"},{"location":"github_action_workflows/pr/#linters","title":"linters","text":"<ul> <li>Please visit: Linter Checks</li> </ul>"},{"location":"github_action_workflows/pr/#terraform-docs","title":"terraform-docs","text":"<ul> <li>Please visit: Terraform Docs Check</li> </ul>"},{"location":"github_action_workflows/pr/#infracost","title":"infracost","text":"<ul> <li>Please visit: Infracost</li> </ul> <p>Info</p> <p>You may notice additional workflows in the navigation menu. These are not called by this main orchestrator and run on their own cadences!</p>"},{"location":"github_action_workflows/sast/","title":"SAST Checks","text":"<p>This workflow is a reusable one I made to run SAST (Static Application Security Testing) tooling. This will scan the code for best practices and potential security violations, such as:</p> <ul> <li>Ensure log groups are encrypted</li> <li>Prevent S3 public access to S3 buckets</li> <li>Ensure DynamoDB tables have delete protection and PITR (Point in time recovery) enabled</li> </ul>"},{"location":"github_action_workflows/sast/#calling-workflow","title":"Calling Workflow","text":".github/workflows/pr.yml<pre><code>sast-checks:\n  uses: ./.github/workflows/sast.yml\n</code></pre>"},{"location":"github_action_workflows/sast/#workflow","title":"Workflow","text":".github/workflows/sast.yml<pre><code>name: sast_checks\n\non:\n  workflow_call:\n\ndefaults:\n  run:\n    shell: bash\n\njobs:\n  checkov:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check Out Code\n        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n        with:\n            ref: ${{ github.event.pull_request.head.ref }}\n\n      - name: Run Checkov\n        uses: bridgecrewio/checkov-action@99bb2caf247dfd9f03cf984373bc6043d4e32ebf # v12\n        with:\n          config_file: .checkov.yml\n  trivy:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check Out Code\n        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n        with:\n            ref: ${{ github.event.pull_request.head.ref }}\n\n      - name: Run Trivy \n        uses: aquasecurity/trivy-action@915b19bbe73b92a6cf82a1bc12b087c9a19a5fe2 # v0.28.0\n        with:\n          trivy-config: .trivy.yml\n          scan-type: 'config'\n          exit-code: '1'\n</code></pre>"},{"location":"github_action_workflows/sast/#configuration","title":"Configuration","text":"<p>The workflow in itself is very simple, we clone out the PR branch and install the tools and run them within their official workflows. </p>"},{"location":"github_action_workflows/sast/#jobs","title":"Jobs","text":"<p>There are two jobs for this workflow:</p> <ol> <li>checkov</li> <li>Trivy</li> </ol>"},{"location":"github_action_workflows/sast/#checkov","title":"checkov","text":".github/workflows/sast.yml<pre><code>checkov:\n  runs-on: ubuntu-latest\n  steps:\n    - name: Check Out Code\n      uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n      with:\n          ref: ${{ github.event.pull_request.head.ref }}\n\n    - name: Run Checkov\n      uses: bridgecrewio/checkov-action@99bb2caf247dfd9f03cf984373bc6043d4e32ebf # v12\n      with:\n        config_file: .checkov.yml\n</code></pre> <p>This workflow checks out the PR branch and then calls the official checkov GitHub Action. The behaviour of the tool is controlled through the config file present at the root of the repo: <code>.checkov.yml</code></p> <p>Note</p> <p>When developing this workflow I did note the official Action has not been updated in a very long time. When running it also runs a one major version of the tool itself. As I expand on improvements made to this Minicamp, I will aim to create a new one that simply installs it uses <code>pip</code>.</p>"},{"location":"github_action_workflows/sast/#trivy","title":"Trivy","text":".github/workflows/sast.yml<pre><code>trivy:\n  runs-on: ubuntu-latest\n  steps:\n    - name: Check Out Code\n      uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n      with:\n          ref: ${{ github.event.pull_request.head.ref }}\n\n    - name: Run Trivy \n      uses: aquasecurity/trivy-action@915b19bbe73b92a6cf82a1bc12b087c9a19a5fe2 # v0.28.0\n      with:\n        trivy-config: .trivy.yml\n        scan-type: 'config'\n        exit-code: '1'\n</code></pre> <p>This workflow checks out the PR branch and then calls the official Trivy GitHub Action. The behaviour of the tool is controlled through the config file present at the root of the repo: <code>.trivy.yml</code>, however it also requires passing in additional variables to work.</p> <p>Note</p> <p>The official Trivy action is a Docker-based GitHub Action. I've seen it takes upwards of minutes sometimes to run.</p>"},{"location":"github_action_workflows/terraform_docs/","title":"Terraform Docs","text":"<p>This workflow checks to ensure that <code>terraform-docs</code> has been ran in a specified directory. The aim is to check any changes made to the <code>tofu/</code> directory have been captured e.g. new resources, data sources, modules etc. This then helps consumers/developers understand quickly how the module itself behaves.</p>"},{"location":"github_action_workflows/terraform_docs/#calling-workflow","title":"Calling Workflow","text":".github/workflows/pr.yml<pre><code>terraform-docs:\n  uses: ./.github/workflows/terraform_docs.yml\n  with:\n    config_file: \".terraform-docs.yml\"\n    directory: \"tofu\"\n    tfdoc_version: \"v0.19.0\"\n</code></pre>"},{"location":"github_action_workflows/terraform_docs/#workflow","title":"Workflow","text":".github/workflows/terraform_docs.yml<pre><code>name: Terraform Docs Check\non:\n  workflow_call:\n    inputs:\n      config_file:\n        required: true\n        type: string\n      directory:\n        required: false\n        type: string\n        default: .\n      tfdoc_version:\n        required: false\n        type: string\n        default: v0.19.0\n\ndefaults:\n  run:\n    shell: bash\n\njobs:\n  check:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check Out Code\n        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n\n      - name: Install Terraform Docs\n        run: |\n          cd /tmp\n          curl -sSLo ./terraform-docs.tar.gz https://terraform-docs.io/dl/${{ inputs.tfdoc_version }}/terraform-docs-${{ inputs.tfdoc_version }}-$(uname)-amd64.tar.gz\n          tar -xzf terraform-docs.tar.gz\n          chmod +x terraform-docs\n          sudo mv terraform-docs /usr/local/bin/terraform-docs\n\n      - name: Print Terraform Docs Version\n        run: terraform-docs --version\n\n      - name: Terraform Docs Check\n        run: terraform-docs -c ${{ inputs.config_file }} --output-check ${{ inputs.directory }} \n</code></pre>"},{"location":"github_action_workflows/terraform_docs/#configuration","title":"Configuration","text":"<p>This Action was custom made by me, although there is an official GitHub Action available. Upon using it, I noticed the config file when passed in is completely ignored. Unfortunately it seems to be a bug as others have reported it as well: https://github.com/terraform-docs/gh-actions/issues/136.</p>"},{"location":"github_action_workflows/terraform_docs/#jobs","title":"Jobs","text":""},{"location":"github_action_workflows/terraform_docs/#check","title":"check","text":".github/workflows/pr.yml<pre><code>check:\n  runs-on: ubuntu-latest\n  steps:\n    - name: Check Out Code\n      uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n\n    - name: Install Terraform Docs\n      run: |\n        cd /tmp\n        curl -sSLo ./terraform-docs.tar.gz https://terraform-docs.io/dl/${{ inputs.tfdoc_version }}/terraform-docs-${{ inputs.tfdoc_version }}-$(uname)-amd64.tar.gz\n        tar -xzf terraform-docs.tar.gz\n        chmod +x terraform-docs\n        sudo mv terraform-docs /usr/local/bin/terraform-docs\n\n    - name: Print Terraform Docs Version\n      run: terraform-docs --version\n\n    - name: Terraform Docs Check\n      run: terraform-docs -c ${{ inputs.config_file }} --output-check ${{ inputs.directory }} \n</code></pre> <p>Here we download the binary passed in via the calling workflow input, which at the time of writing is <code>v0.19.0</code> which is passed to the URL which uses <code>curl</code> to then download it, extract it using <code>tar</code>, make it executable and then move it into a directory that is in <code>$PATH</code>. </p> <p>Note</p> <p>I could use the <code>$GITHUB_PATH</code> environment variable to append a new directory to the $PATH, but my own Linux experience is to move user owned binaries into the <code>/usr/local/bin</code> directory.</p> <p>We then confirm the version as part of the workflow, pass in the config file and then use the <code>--output-check</code> flag which returns which locations haven't been updated based on the latest OpenTofu configuration.</p>"},{"location":"github_action_workflows/tofu_apply/","title":"Tofu Apply","text":"<p>This workflow simply runs a <code>tofu apply</code> into a GitHub Environment following an approval of the PR and then a merge into the target branch. Also knows as \"apply after merge\". </p> <p>Warning</p> <p>The GitHub Environment has a condition that any workflow MUST be approved before it can be ran inside. This obviously then stops anyone just deploying anything without human intervention.</p>"},{"location":"github_action_workflows/tofu_apply/#workflow","title":"Workflow","text":".github/workflows/tofu_apply.yml<pre><code>name: Tofu Apply\n\non:\n  push:\n    branches:\n      - dev\n      - main\n    paths:\n      - 'tofu/**'\n\ndefaults:\n  run:\n    shell: bash\n\npermissions:\n  contents: read\n  id-token: write\n\nenv:\n  TF_IN_AUTOMATION: \"true\"\n  TF_INPUT: \"false\"\n\njobs:\n  apply:\n    runs-on: ubuntu-latest\n    environment: ${{ github.ref_name == 'main' &amp;&amp; 'prod' || 'dev' }}\n    steps:\n      - name: Check Out Code\n        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n\n      - name: Configure OpenTofu\n        uses: opentofu/setup-opentofu@12f4debbf681675350b6cd1f0ff8ecfbda62027b # v1.0.4\n\n      - name: Print Tofu Version\n        run: tofu --version\n\n      - name: Get OIDC Token File\n        run: |\n          curl -s -H \"Authorization: bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN\" \"$ACTIONS_ID_TOKEN_REQUEST_URL&amp;audience=sts.amazonaws.com\" | jq -r .value &gt; /tmp/web-identity-token\n\n      - name: Tofu Init\n        run: tofu init --backend-config=\"key=${{ github.event.repository.name }}/${{ github.ref_name == 'main' &amp;&amp; 'prod' || 'dev' }}/terraform.tfstate\" --var-file=\"${{ github.ref_name == 'main' &amp;&amp; 'prod' || 'dev' }}.tfvars\"\n        working-directory: ${{ github.workspace }}/tofu\n\n      - name: Tofu Apply\n        run: tofu apply --var-file=\"${{ github.ref_name == 'main' &amp;&amp; 'prod' || 'dev' }}.tfvars\" -no-color --auto-approve\n        working-directory: ${{ github.workspace }}/tofu\n</code></pre>"},{"location":"github_action_workflows/tofu_apply/#configuration","title":"Configuration","text":"<p>This workflow will only run on a push to <code>dev</code> and <code>main</code> which correspond to our two environments in AWS. Additionally it will only run if the <code>tofu/</code> directory has been updated as that is where the OpenTofu configuration is. It uses two environment variables that help tailor the output of messages to the system the tool is interacting with, such as a CI/CD Pipeline where it's non interactive.</p> <p>Here we use the <code>environment</code> keyword to tell the workflow that it will run in a GitHub Environment. As we only have two environments, we use a condition using the <code>ref_name</code> in the <code>github</code> context. If the workflow is running inside the <code>main</code> branch, we know the environment is <code>prod</code>, otherwise if it is running in <code>dev</code> we know the environment is <code>dev</code></p> <p>Note</p> <p>As an improvement I would make this more dynamic and not just for two environments.</p> <p>As we need to authenticate with AWS, we need to grant the <code>id-token: write</code> permission so we can request the JWT using OIDC. The <code>contents: read</code> permission is to allow the PR branch to be checked out. </p> <p>As mentioned in Tofu Checks, we use the <code>TF_IN_AUTOMATION</code> and <code>TF_INPUT</code> environment variables to control the output OpenTofu shows to the user. In this case a non-interactive CI/CD pipeline.</p>"},{"location":"github_action_workflows/tofu_apply/#jobs","title":"Jobs","text":"<p>There is only one job in this workflow:</p> <ol> <li>apply</li> </ol>"},{"location":"github_action_workflows/tofu_apply/#apply","title":"apply","text":".github/workflows/tofu_apply.yml<pre><code>apply:\n  runs-on: ubuntu-latest\n  environment: ${{ github.ref_name == 'main' &amp;&amp; 'prod' || 'dev' }}\n  steps:\n    - name: Check Out Code\n      uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n\n    - name: Configure OpenTofu\n      uses: opentofu/setup-opentofu@12f4debbf681675350b6cd1f0ff8ecfbda62027b # v1.0.4\n\n    - name: Print Tofu Version\n      run: tofu --version\n\n    - name: Get OIDC Token File\n      run: |\n        curl -s -H \"Authorization: bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN\" \"$ACTIONS_ID_TOKEN_REQUEST_URL&amp;audience=sts.amazonaws.com\" | jq -r .value &gt; /tmp/web-identity-token\n\n    - name: Tofu Init\n      run: tofu init --backend-config=\"key=${{ github.event.repository.name }}/${{ github.ref_name == 'main' &amp;&amp; 'prod' || 'dev' }}/terraform.tfstate\" --var-file=\"${{ github.ref_name == 'main' &amp;&amp; 'prod' || 'dev' }}.tfvars\"\n      working-directory: ${{ github.workspace }}/tofu\n\n    - name: Tofu Apply\n      run: tofu apply --var-file=\"${{ github.ref_name == 'main' &amp;&amp; 'prod' || 'dev' }}.tfvars\" -no-color --auto-approve\n      working-directory: ${{ github.workspace }}/tofu\n</code></pre> <p>The base branch is checked out and then OpenTofu is installed into the environment using their official Action. We confirm the version of OpenTofu being used in the workflow, and then request the OIDC Token File to authenticate with AWS. </p> <p>After we initialise OpenTofu to download the providers used: <code>aws</code> and <code>http</code>. You might also notice we're using a partial backend here, as we have the workflow managing the <code>key</code> to the state file. We could technically pass in a .hcl file that also has the backend configuration, but wanted to make the OpenTofu workflow as simple as possible.</p> <p>The apply is then automatically ran and infrastructure is deployed into the destination environment.</p>"},{"location":"github_action_workflows/tofu_checks/","title":"Tofu Checks","text":"<p>The purpose of the Tofu Checks workflow is to ensure that the code is:</p> <ol> <li>Code is formatted to the canonical OpenTofu standards</li> <li>The configuration is validated</li> <li>Custom tests pass</li> </ol>"},{"location":"github_action_workflows/tofu_checks/#calling-workflow","title":"Calling Workflow","text":".github/workflows/pr.yml<pre><code>jobs:\n  tofu-checks:\n    permissions:\n      contents: read\n      id-token: write\n      pull-requests: write\n    uses: ./.github/workflows/tofu_checks.yml\n    with:\n      tf_var_file: \"${{ github.base_ref == 'main' &amp;&amp; 'prod' || 'dev' }}.tfvars\"\n</code></pre>"},{"location":"github_action_workflows/tofu_checks/#workflow","title":"Workflow","text":".github/workflows/tofu_checks.yml<pre><code>name: tofu-checks\n\non:\n  workflow_call:\n    inputs:\n      tf_var_file:\n        required: true\n        type: string\n      test_directory:\n        required: false\n        type: string\n        default: \"tests\"\n\ndefaults:\n  run:\n    shell: bash\n\nenv:\n  TF_IN_AUTOMATION: \"true\"\n  TF_INPUT: \"false\"\n\njobs:\n  fmt:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check Out Code\n        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n        with:\n            ref: ${{ github.event.pull_request.head.ref }}\n\n      - name: Configure OpenTofu\n        uses: opentofu/setup-opentofu@12f4debbf681675350b6cd1f0ff8ecfbda62027b # v1.0.4\n\n      - name: Print Tofu Version\n        run: tofu --version\n\n      - name: Tofu Format Check\n        run: tofu fmt --check\n        working-directory: ${{ github.workspace }}/tofu\n\n  validate:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check Out Code\n        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n        with:\n            ref: ${{ github.event.pull_request.head.ref }}\n\n      - name: Configure OpenTofu\n        uses: opentofu/setup-opentofu@12f4debbf681675350b6cd1f0ff8ecfbda62027b # v1.0.4\n\n      - name: Print Tofu Version\n        run: tofu --version\n        working-directory: ${{ github.workspace }}/tofu\n\n      - name: Tofu Init\n        run: tofu init --backend=false\n        working-directory: ${{ github.workspace }}/tofu\n\n      - name: Tofu Validate\n        run: tofu validate\n        working-directory: ${{ github.workspace }}/tofu\n\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check Out Code\n        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n        with:\n            ref: ${{ github.event.pull_request.head.ref }}\n\n      - name: Configure OpenTofu\n        uses: opentofu/setup-opentofu@12f4debbf681675350b6cd1f0ff8ecfbda62027b # v1.0.4\n\n      - name: Print Tofu Version\n        run: tofu --version\n\n      - name: Get OIDC Token File\n        run: |\n          curl -s -H \"Authorization: bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN\" \"$ACTIONS_ID_TOKEN_REQUEST_URL&amp;audience=sts.amazonaws.com\" | jq -r .value &gt; /tmp/web-identity-token\n\n      - name: Tofu Init\n        run: tofu init -backend=false\n        working-directory: ${{ github.workspace }}/tofu\n\n      - name: Tofu Test\n        id: test\n        run: tofu test -var-file=\"${{ inputs.tf_var_file }}\" -test-directory=\"${{ inputs.test_directory }}\"\n        working-directory: ${{ github.workspace }}/tofu\n\n  post-comment:\n    runs-on: ubuntu-latest\n    needs: [fmt, validate, test]\n    steps:\n      - name: Post Comment\n        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1\n        with:\n          script: |\n            const fmtResult = `**Tofu Format Check:** ${{ needs.fmt.result }}`;\n            const validateResult = `**Tofu Validate:** ${{ needs.validate.result }}`;\n            const testResult = `**Tofu Test:** ${{ needs.test.result }}`;\n            const commentBody = `## Tofu Checks Result\\n\\n${fmtResult}\\n${validateResult}\\n${testResult}`;\n\n            const { data: comments } = await github.rest.issues.listComments({\n              owner: context.repo.owner,\n              repo: context.repo.repo,\n              issue_number: context.issue.number,\n            });\n\n            const botComment = comments.find(comment =&gt; comment.user.login === 'github-actions[bot]' &amp;&amp; comment.body.includes(\"## Tofu Checks Result\"));\n\n            if (!botComment) {\n              await github.rest.issues.createComment({\n                owner: context.repo.owner,\n                repo: context.repo.repo,\n                issue_number: context.issue.number,\n                body: commentBody,\n              });\n            } else {\n              await github.rest.issues.updateComment({\n                owner: context.repo.owner,\n                repo: context.repo.repo,\n                comment_id: botComment.id,\n                body: commentBody,\n              });\n            }\n</code></pre> <p>Info</p> <p>This workflow uses a different <code>on:</code> keyword option, <code>workflow_call</code> - this means it can be called by another workflow only!</p>"},{"location":"github_action_workflows/tofu_checks/#configuration","title":"Configuration","text":"<p>Within the workflow, there are two inputs:</p> <ol> <li><code>tf_var_file</code><ol> <li>Path to the <code>.tfvars</code> file to be used in <code>tofu</code> operations via <code>-var-file</code></li> </ol> </li> <li><code>test_directory</code><ol> <li>The directory that stores the <code>*.tftest.hcl</code> files that <code>tofu test</code> runs</li> </ol> </li> </ol> <p>This is all controlled via: </p> .github/workflows/tofu_checks.yml<pre><code>on:\n  workflow_call:\n    inputs:\n      tf_var_file:\n        required: true\n        type: string\n      test_directory:\n        required: false\n        type: string\n        default: \"tests\"\n</code></pre> <p>This workflow also implements some environment variables, that are present to all jobs and their associated steps in the workflow. This is controlled via the <code>env</code> keyword. These are:</p> .github/workflows/tofu_checks.yml<pre><code>env:\n  TF_IN_AUTOMATION: \"true\"\n  TF_INPUT: \"false\"\n</code></pre> <p>These environment variables are used by OpenTofu to influence how information is presented by the tool, for example in CI/CD pipelines.</p>"},{"location":"github_action_workflows/tofu_checks/#jobs","title":"Jobs","text":"<p>This workflow has 4 jobs:</p> <ol> <li><code>fmt</code></li> <li><code>validate</code></li> <li><code>test</code></li> <li><code>post-comment</code></li> </ol>"},{"location":"github_action_workflows/tofu_checks/#fmt","title":"fmt","text":".github/workflows/tofu_checks.yml<pre><code>fmt:\n runs-on: ubuntu-latest\n steps:\n   - name: Check Out Code\n     uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n     with:\n         ref: ${{ github.event.pull_request.head.ref }}\n\n   - name: Configure OpenTofu\n     uses: opentofu/setup-opentofu@12f4debbf681675350b6cd1f0ff8ecfbda62027b # v1.0.4\n\n   - name: Print Tofu Version\n     run: tofu --version\n\n   - name: Tofu Format Check\n     run: tofu fmt --check\n     working-directory: ${{ github.workspace }}/tofu\n</code></pre> <p>This job installs OpenTofu, prints the version using <code>tofu --version</code> and then runs the <code>tofu fmt --check</code> command inside the <code>tofu/</code> directory. The use of <code>${{ github.workspace }}</code> is a context variable, which in this case points to the root of the repo.</p> <p>Info</p> <p><code>working-directory</code> is not specific to OpenTofu, in fact it's a keyword in the GitHub Actions syntax in which you can easily specify which directory to run a step in!</p> .github/workflows/tofu_checks.yml<pre><code>working-directory: ${{ github.workspace }}/tofu\n</code></pre>"},{"location":"github_action_workflows/tofu_checks/#validate","title":"validate","text":".github/workflows/tofu_checks.yml<pre><code>validate:\n runs-on: ubuntu-latest\n steps:\n   - name: Check Out Code\n     uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n     with:\n         ref: ${{ github.event.pull_request.head.ref }}\n\n   - name: Configure OpenTofu\n     uses: opentofu/setup-opentofu@12f4debbf681675350b6cd1f0ff8ecfbda62027b # v1.0.4\n\n   - name: Print Tofu Version\n     run: tofu --version\n     working-directory: ${{ github.workspace }}/tofu\n\n   - name: Tofu Init\n     run: tofu init --backend=false\n     working-directory: ${{ github.workspace }}/tofu\n\n   - name: Tofu Validate\n     run: tofu validate\n     working-directory: ${{ github.workspace }}/tofu\n</code></pre> <p>This is very similar to the <code>fmt</code> workflow, with the exception we are using <code>tofu init</code> and <code>tofu validate</code>. This checks to ensure the OpenTofu configuration is valid, but requires <code>tofu init</code> to be ran so the providers can be downloaded!</p> <p>Tip</p> <p>You can use the <code>--backend=false</code> flag in your init command to speed up this step when using <code>tofu validate</code>. This is because we don't need to connect to the remote state file in S3 for <code>tofu validate</code> to work.</p>"},{"location":"github_action_workflows/tofu_checks/#test","title":"test","text":".github/workflows/tofu_checks.yml<pre><code>test:\n runs-on: ubuntu-latest\n steps:\n   - name: Check Out Code\n     uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n     with:\n         ref: ${{ github.event.pull_request.head.ref }}\n\n   - name: Configure OpenTofu\n     uses: opentofu/setup-opentofu@12f4debbf681675350b6cd1f0ff8ecfbda62027b # v1.0.4\n\n   - name: Print Tofu Version\n     run: tofu --version\n\n   - name: Get OIDC Token File\n     run: |\n       curl -s -H \"Authorization: bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN\" \"$ACTIONS_ID_TOKEN_REQUEST_URL&amp;audience=sts.amazonaws.com\" | jq -r .value &gt; /tmp/web-identity-token\n\n   - name: Tofu Init\n     run: tofu init -backend=false\n     working-directory: ${{ github.workspace }}/tofu\n\n   - name: Tofu Test\n     id: test\n     run: tofu test -var-file=\"${{ inputs.tf_var_file }}\" -test-directory=\"${{ inputs.test_directory }}\"\n     working-directory: ${{ github.workspace }}/tofu\n</code></pre> <p>Like other jobs, we're configuring OpenTofu, initialising it and now running <code>tofu test</code> - OpenTofu's native testing framework. However you may notice this one job has an additional step - getting the OIDC Token File using <code>curl</code>. This is because we need to authenticate with our role in AWS for some of these tests to work. </p> <p>Info</p> <p>You might be wondering why I'm not using the official AWS action to authenticate to AWS The reason why I'm using this, and not the official AWS action to authenticate is explained"},{"location":"github_action_workflows/tofu_checks/#post-comment","title":"post-comment","text":".github/workflows/tofu_checks.yml<pre><code>post-comment:\n  runs-on: ubuntu-latest\n  needs: [fmt, validate, test]\n  steps:\n    - name: Post Comment\n      uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1\n      with:\n        script: |\n          const fmtResult = `**Tofu Format Check:** ${{ needs.fmt.result }}`;\n          const validateResult = `**Tofu Validate:** ${{ needs.validate.result }}`;\n          const testResult = `**Tofu Test:** ${{ needs.test.result }}`;\n          const commentBody = `## Tofu Checks Result\\n\\n${fmtResult}\\n${validateResult}\\n${testResult}`;\n\n          const { data: comments } = await github.rest.issues.listComments({\n            owner: context.repo.owner,\n            repo: context.repo.repo,\n            issue_number: context.issue.number,\n          });\n\n          const botComment = comments.find(comment =&gt; comment.user.login === 'github-actions[bot]' &amp;&amp; comment.body.includes(\"## Tofu Checks Result\"));\n\n          if (!botComment) {\n            await github.rest.issues.createComment({\n              owner: context.repo.owner,\n              repo: context.repo.repo,\n              issue_number: context.issue.number,\n              body: commentBody,\n            });\n          } else {\n            await github.rest.issues.updateComment({\n              owner: context.repo.owner,\n              repo: context.repo.repo,\n              comment_id: botComment.id,\n              body: commentBody,\n            });\n          }\n</code></pre> <p>This job requires the other steps to be completed first and this is by design. You will see the workflow uses the <code>needs</code> keyword, meaning that the other jobs need to be completed before <code>post-comment</code> can be ran. It takes the output of the other 3 jobs and whether they succeeded, or failed. It then uses <code>actions/github-script</code> to run some Javascript that posts the results to the PR. </p> <p>You can see an example below:</p> <p></p>"},{"location":"github_action_workflows/tofu_destroy/","title":"Tofu Destroy","text":"<p>This workflow is very similar to the Tofu Apply workflow, with the only difference is runs <code>tofu destroy</code> instead of <code>tofu apply</code>. </p> <p>Warning</p> <p>The GitHub Environment has a condition that any workflow MUST be approved before it can be ran inside. This obviously then stops anyone just destroying anything without human intervention.</p> <p>This will destroy all infrastructure inside the destination environment.</p>"},{"location":"github_action_workflows/tofu_destroy/#workflow","title":"Workflow","text":".github/workflows/tofu_destroy.yml<pre><code>name: Tofu Destroy\n\non:\n  workflow_dispatch: {}\n\ndefaults:\n  run:\n    shell: bash\n\npermissions:\n  contents: read\n  id-token: write\n\nenv:\n  TF_IN_AUTOMATION: \"true\"\n  TF_INPUT: \"false\"\n\njobs:\n  destroy:\n    runs-on: ubuntu-latest\n    environment: ${{ github.ref_name == 'main' &amp;&amp; 'prod' || 'dev' }}\n    steps:\n      - name: Check Out Code\n        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n\n      - name: Configure OpenTofu\n        uses: opentofu/setup-opentofu@12f4debbf681675350b6cd1f0ff8ecfbda62027b # v1.0.4\n\n      - name: Print Tofu Version\n        run: tofu --version\n\n      - name: Get OIDC Token File\n        run: |\n          curl -s -H \"Authorization: bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN\" \"$ACTIONS_ID_TOKEN_REQUEST_URL&amp;audience=sts.amazonaws.com\" | jq -r .value &gt; /tmp/web-identity-token\n\n      - name: Tofu Init\n        run: tofu init --backend-config=\"key=${{ github.event.repository.name }}/${{ github.ref_name == 'main' &amp;&amp; 'prod' || 'dev' }}/terraform.tfstate\" --var-file=\"${{ github.ref_name == 'main' &amp;&amp; 'prod' || 'dev' }}.tfvars\"\n        working-directory: ${{ github.workspace }}/tofu\n\n      - name: Tofu Destroy\n        run: tofu destroy --var-file=\"${{ github.ref_name == 'main' &amp;&amp; 'prod' || 'dev' }}.tfvars\" --no-color --auto-approve\n        working-directory: ${{ github.workspace }}/tofu\n</code></pre>"},{"location":"github_action_workflows/tofu_destroy/#configuration","title":"Configuration","text":"<p>This workflow will only run on a push to <code>dev</code> and <code>main</code> which correspond to our two environments in AWS. Additionally it will only run if the <code>tofu/</code> directory has been updated as that is where the OpenTofu configuration is. It uses two environment variables that help tailor the output of messages to the system the tool is interacting with, such as a CI/CD Pipeline where it's non interactive.</p> <p>Here we use the <code>environment</code> keyword to tell the workflow that it will run in a GitHub Environment. As we only have two environments, we use a condition using the <code>ref_name</code> in the <code>github</code> context. If the workflow is running inside the <code>main</code> branch, we know the environment is <code>prod</code>, otherwise if it is running in <code>dev</code> we know the environment is <code>dev</code></p> <p>Note</p> <p>As an improvement I would make this more dynamic and not just for two environments.</p> <p>As we need to authenticate with AWS, we need to grant the <code>id-token: write</code> permission so we can request the JWT using OIDC. The <code>contents: read</code> permission is to allow the PR branch to be checked out. </p> <p>As mentioned in Tofu Checks, we use the <code>TF_IN_AUTOMATION</code> and <code>TF_INPUT</code> environment variables to control the output OpenTofu shows to the user. In this case a non-interactive CI/CD pipeline.</p>"},{"location":"github_action_workflows/tofu_destroy/#jobs","title":"Jobs","text":"<p>There is only one job in this workflow:</p> <ol> <li>destroy</li> </ol>"},{"location":"github_action_workflows/tofu_destroy/#destroy","title":"destroy","text":".github/workflows/tofu_destroy.yml<pre><code>destroy:\n  runs-on: ubuntu-latest\n  environment: ${{ github.ref_name == 'main' &amp;&amp; 'prod' || 'dev' }}\n  steps:\n    - name: Check Out Code\n      uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n\n    - name: Configure OpenTofu\n      uses: opentofu/setup-opentofu@12f4debbf681675350b6cd1f0ff8ecfbda62027b # v1.0.4\n\n    - name: Print Tofu Version\n      run: tofu --version\n\n    - name: Get OIDC Token File\n      run: |\n        curl -s -H \"Authorization: bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN\" \"$ACTIONS_ID_TOKEN_REQUEST_URL&amp;audience=sts.amazonaws.com\" | jq -r .value &gt; /tmp/web-identity-token\n\n    - name: Tofu Init\n      run: tofu init --backend-config=\"key=${{ github.event.repository.name }}/${{ github.ref_name == 'main' &amp;&amp; 'prod' || 'dev' }}/terraform.tfstate\" --var-file=\"${{ github.ref_name == 'main' &amp;&amp; 'prod' || 'dev' }}.tfvars\"\n      working-directory: ${{ github.workspace }}/tofu\n\n    - name: Tofu Destroy\n      run: tofu destroy --var-file=\"${{ github.ref_name == 'main' &amp;&amp; 'prod' || 'dev' }}.tfvars\" --no-color --auto-approve\n      working-directory: ${{ github.workspace }}/tofu\n</code></pre> <p>The base branch is checked out and then OpenTofu is installed into the environment using their official Action. We confirm the version of OpenTofu being used in the workflow, and then request the OIDC Token File to authenticate with AWS. </p> <p>After we initialise OpenTofu to download the providers used: <code>aws</code> and <code>http</code>. You might also notice we're using a partial backend here, as we have the workflow managing the <code>key</code> to the state file. We could technically pass in a .hcl file that also has the backend configuration, but wanted to make the OpenTofu workflow as simple as possible.</p> <p>The destroy is then automatically ran and infrastructure is deployed into the destination environment.</p>"},{"location":"github_action_workflows/tofu_plan/","title":"Tofu Plan","text":"<p>This workflow crates a plan, which is what OpenTofu wants to do with your infrastructure. In that it compares the state vs your actual configuration. This is reusable, meaning it can be called by other workflows, in this case it is called by the PR workflow.</p> <p>Once the plan has been created it is outputted to the PR.</p>"},{"location":"github_action_workflows/tofu_plan/#calling-workflow","title":"Calling Workflow","text":".github/workflows/pr.yml<pre><code>tofu-plan:\n  permissions:\n    contents: read\n    id-token: write\n    pull-requests: write\n  uses: ./.github/workflows/tofu_plan.yml\n  with:\n    environment: ${{ github.base_ref == 'main' &amp;&amp; 'prod' || 'dev' }}\n    tf_var_file: \"${{ github.base_ref == 'main' &amp;&amp; 'prod' || 'dev' }}.tfvars\"\n</code></pre>"},{"location":"github_action_workflows/tofu_plan/#workflow","title":"Workflow","text":".github/workflows/tofu_plan.yml<pre><code>name: Tofu Plan\n\non:\n  workflow_call:\n    inputs:\n      environment:\n        required: true\n        type: string\n      tf_var_file:\n        required: true\n        type: string\n\ndefaults:\n  run:\n    shell: bash\n\nenv:\n  TF_IN_AUTOMATION: \"true\"\n  TF_INPUT: \"false\"\n\njobs:\n  plan:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check Out Code\n        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n        with:\n            ref: ${{ github.event.pull_request.head.ref }}\n\n      - name: Configure OpenTofu\n        uses: opentofu/setup-opentofu@12f4debbf681675350b6cd1f0ff8ecfbda62027b # v1.0.4\n\n      - name: Print Tofu Version\n        run: tofu --version\n\n      - name: Get OIDC Token File\n        run: |\n          curl -s -H \"Authorization: bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN\" \"$ACTIONS_ID_TOKEN_REQUEST_URL&amp;audience=sts.amazonaws.com\" | jq -r .value &gt; /tmp/web-identity-token\n\n      - name: Tofu Init\n        run: tofu init --backend-config=\"key=${{ github.event.repository.name }}/${{ inputs.environment }}/terraform.tfstate\" --var-file=\"${{ inputs.tf_var_file }}\"\n        working-directory: ${{ github.workspace }}/tofu\n\n      - name: Tofu Plan\n        id: plan\n        run: tofu plan --var-file=\"${{ inputs.tf_var_file }}\" -no-color -detailed-exitcode -out=tf.plan\n        working-directory: ${{ github.workspace }}/tofu\n\n      - name: Output Tofu Plan in PR Comment\n        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1\n        with:\n          script: |\n            const fs = require('fs');\n            const { execSync } = require('child_process');\n\n            const planOutput = execSync('tofu show -no-color tf.plan', {\n              cwd: 'tofu'\n            }).toString();\n\n            const plan = planOutput.length &gt; 65000 ? planOutput.substring(0, 65000) + \" ...\" : planOutput;\n            const truncateMessage = planOutput.length &gt; 65000 ? `&gt; [!NOTE]\\n&gt; The plan output is too long so it has been truncated. You can view the full plan at: ${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}` : \"\";\n            const commentBody = `## Tofu Plan for \\`${{ github.base_ref == 'main' &amp;&amp; 'prod' || 'dev' }}\\`:\\n&lt;details&gt;&lt;summary&gt;Show Plan&lt;/summary&gt;\\n\\n\\`\\`\\`hcl\\n${plan}\\n\\`\\`\\`\\n&lt;/details&gt;\\n\\n${truncateMessage}`;\n\n            const { data: comments } = await github.rest.issues.listComments({\n              owner: context.repo.owner,\n              repo: context.repo.repo,\n              issue_number: context.payload.number,\n            });\n\n            const botComment = comments.find(comment =&gt; comment.user.id === 41898282 &amp;&amp; comment.body.includes(\"## Tofu Plan for\"));\n\n            if (!botComment) {\n              github.rest.issues.createComment({\n                issue_number: context.issue.number,\n                owner: context.repo.owner,\n                repo: context.repo.repo,\n                body: commentBody,\n              });\n            } else {\n              github.rest.issues.updateComment({\n                owner: context.repo.owner,\n                repo: context.repo.repo,\n                comment_id: botComment.id,\n                body: commentBody,\n              });\n            }\n</code></pre>"},{"location":"github_action_workflows/tofu_plan/#configuration","title":"Configuration","text":"<p>This workflow has two inputs:</p> <ol> <li><code>environment</code><ol> <li>The environment to deploy the infrastructure inside</li> </ol> </li> <li><code>tf_var_file</code><ol> <li>The var file to use for the deployment into <code>environment</code></li> </ol> </li> </ol> <p>We also use two environment variables that influence how the output of OpenTofu is tailored to the system it is running in:</p> <ol> <li><code>TF_IN_AUTOMATION</code></li> <li><code>TF_INPUT</code></li> </ol>"},{"location":"github_action_workflows/tofu_plan/#jobs","title":"Jobs","text":"<p>This workflow has one job:</p> <ol> <li>plan</li> </ol>"},{"location":"github_action_workflows/tofu_plan/#plan","title":"plan","text":".github/workflows/tofu_plan.yml<pre><code>plan:\n  runs-on: ubuntu-latest\n  steps:\n    - name: Check Out Code\n      uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n      with:\n          ref: ${{ github.event.pull_request.head.ref }}\n\n    - name: Configure OpenTofu\n      uses: opentofu/setup-opentofu@12f4debbf681675350b6cd1f0ff8ecfbda62027b # v1.0.4\n\n    - name: Print Tofu Version\n      run: tofu --version\n\n    - name: Get OIDC Token File\n      run: |\n        curl -s -H \"Authorization: bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN\" \"$ACTIONS_ID_TOKEN_REQUEST_URL&amp;audience=sts.amazonaws.com\" | jq -r .value &gt; /tmp/web-identity-token\n\n    - name: Tofu Init\n      run: tofu init --backend-config=\"key=${{ github.event.repository.name }}/${{ inputs.environment }}/terraform.tfstate\" --var-file=\"${{ inputs.tf_var_file }}\"\n      working-directory: ${{ github.workspace }}/tofu\n\n    - name: Tofu Plan\n      id: plan\n      run: tofu plan --var-file=\"${{ inputs.tf_var_file }}\" -no-color -detailed-exitcode -out=tf.plan\n      working-directory: ${{ github.workspace }}/tofu\n\n    - name: Output Tofu Plan in PR Comment\n      uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1\n      with:\n        script: |\n          const fs = require('fs');\n          const { execSync } = require('child_process');\n\n          const planOutput = execSync('tofu show -no-color tf.plan', {\n            cwd: 'tofu'\n          }).toString();\n\n          const plan = planOutput.length &gt; 65000 ? planOutput.substring(0, 65000) + \" ...\" : planOutput;\n          const truncateMessage = planOutput.length &gt; 65000 ? `&gt; [!NOTE]\\n&gt; The plan output is too long so it has been truncated. You can view the full plan at: ${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}` : \"\";\n          const commentBody = `## Tofu Plan for \\`${{ github.base_ref == 'main' &amp;&amp; 'prod' || 'dev' }}\\`:\\n&lt;details&gt;&lt;summary&gt;Show Plan&lt;/summary&gt;\\n\\n\\`\\`\\`hcl\\n${plan}\\n\\`\\`\\`\\n&lt;/details&gt;\\n\\n${truncateMessage}`;\n\n          const { data: comments } = await github.rest.issues.listComments({\n            owner: context.repo.owner,\n            repo: context.repo.repo,\n            issue_number: context.payload.number,\n          });\n\n          const botComment = comments.find(comment =&gt; comment.user.id === 41898282 &amp;&amp; comment.body.includes(\"## Tofu Plan for\"));\n\n          if (!botComment) {\n            github.rest.issues.createComment({\n              issue_number: context.issue.number,\n              owner: context.repo.owner,\n              repo: context.repo.repo,\n              body: commentBody,\n            });\n          } else {\n            github.rest.issues.updateComment({\n              owner: context.repo.owner,\n              repo: context.repo.repo,\n              comment_id: botComment.id,\n              body: commentBody,\n            });\n          }\n</code></pre> <p>It clones the PR branch and configures OpenTofu, by default it will install the latest version available at runtime. After which the version is printed into the workflow logs and then we use <code>curl</code> to get the OIDC JWT file to be used by OpenTofu which allow us to assume an IAM role into the AWS accounts.</p> <p>Note</p> <p>You may notice I'm not using the official AWS action here to authenticate with AWS, this is explained further in OpenTofu Workflow.</p> <p>We initialise OpenTofu to download the providers and configure access to the remote S3 backend for storing the state file. We then run <code>tofu plan</code> to create a plan and store that in a plan file.</p> <p>Note</p> <p>We are not actually using the plan file when we get to the Tofu Apply stage. It is used when we output the plan to the PR after we do some checks on it regarding length. </p> <p>One improvement I want to make to this is to use the plan file at the <code>apply</code> stage as this can speed up the pipeline amongst giving you other benefits. This is explained further in the OpenTofu Workflow page</p> <p>Presenting the Plan and the Plan Size</p> <p>I explained the rationale for this in the Tofu Plan page, but it is relevant here as well. We output a plan file using the <code>-out</code> parameter of the <code>tofu plan</code> command, then we use <code>tofu show -no-color</code> to present it ready for outputting in the issue. My JavaScript isn't the best, so I found a useful workflow by GitHub user: tmlye that used the <code>execSync</code> function in JavaScript: https://github.com/actions/runner/issues/1733#issuecomment-2447036317. Here is where I hit my second issue, which if you looked at the title of the Issue in that comment will give you a little clue... \"Argument list too long\".</p> <p>If you have a massive plan output, which doesn't necessarily mean a mass amount of resources, but one that returns a big object, such as the <code>data \"http\" \"get\" {}</code> data source using the HTTP provider, you could easily hit this limit. I hit it myself when using the exact same data source to check Grafana application availability using a <code>check</code> block.</p> <p>I found an Issue online in which people came together to come up with a good solution to this problem. You can read more here: https://github.com/actions/github-script/issues/266. In short, we need to truncate the plan output:</p> .github/workflows/tofu_plan.yml<pre><code>const fs = require('fs');\nconst { execSync } = require('child_process');\n\nconst planOutput = execSync('tofu show -no-color tf.plan', {\n  cwd: 'tofu'\n}).toString();\n\nconst plan = planOutput.length &gt; 65000 ? planOutput.substring(0, 65000) + \" ...\" : planOutput;\nconst truncateMessage = planOutput.length &gt; 65000 ? `&gt; [!NOTE]\\n&gt; The plan output is too long so it has been truncated. You can view the full plan at: ${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}` : \"\";\nconst commentBody = `## Tofu Plan for \\`${{ github.base_ref == 'main' &amp;&amp; 'prod' || 'dev' }}\\`:\\n&lt;details&gt;&lt;summary&gt;Show Plan&lt;/summary&gt;\\n\\n\\`\\`\\`hcl\\n${plan}\\n\\`\\`\\`\\n&lt;/details&gt;\\n\\n${truncateMessage}`;\n</code></pre> <p>We convert the plan file into a string, and then use the <code>substring</code> function to take 65000 characters and append a <code>...</code>. If the plan file isn't more than 65000 characters long, we just use the full plan file. Using newer features in GitHub, we create a \"Note\" admonition to alert the user that the plan has been truncated and they can view the full plan at the link created by the issue. This uses a concatenation of multiple <code>context</code> variables to dynamically create it.</p> <p>You may also see that we use <code>-no-color</code> when using <code>tofu show</code>. This is because the \"color\" output is converted to the unicode equivalent, making the plan essentially unreadable. To add this back in, we use the <code>hcl</code> code identifier in the code block quote. I personally prefer seeing a colour output anyway and I imagine others do too!</p> <p>Lastly, we use the <code>&lt;details&gt;</code> and <code>&lt;summary&gt;</code> tags which makes the plan output collapsible in the pull request. I actually prefer this because if you have a massive plan output, it makes the PR/Issue look all cluttered - especially if multiple are ran and your original comment in not updated! You can see this in the screenshot taken above where it says <code>&gt; Show Plan</code>.</p> <p>All this is then presented as a comment to the Pull Request. If another commit happens on the PR, the plan is ran again (assuming the commit updated a file in the <code>tofu</code> directory) and the comment updates.</p> <p>You can see an example below:</p> <p></p> <p></p>"},{"location":"repository/code_of_conduct/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"repository/code_of_conduct/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"repository/code_of_conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the overall   community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or advances of   any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email address,   without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"repository/code_of_conduct/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"repository/code_of_conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official email address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"repository/code_of_conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at hello@kieranlowe.me All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"repository/code_of_conduct/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"repository/code_of_conduct/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"repository/code_of_conduct/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"repository/code_of_conduct/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"repository/code_of_conduct/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"repository/code_of_conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.1, available at https://www.contributor-covenant.org/version/2/1/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"repository/contributing/","title":"Contributing to GitOps-2024","text":"<p>Thank you for considering contributing to GitOps-2024! I welcome contributions from everyone. Here are some guidelines to help you get started.</p>"},{"location":"repository/contributing/#how-to-contribute","title":"How to Contribute","text":"<ol> <li> <p>Fork the repository: Click the \"Fork\" button at the top right of this repository and clone your fork locally.</p> </li> <li> <p>Create a branch: Create a new branch for your changes.</p> </li> </ol> <pre><code>git checkout -b my-feature-branch\n</code></pre> <ol> <li> <p>Make your changes: Make your changes to the codebase.</p> </li> <li> <p>Commit your changes: Commit your changes with a descriptive commit message.</p> </li> </ol> <pre><code>git commit -m \"docs: improve clarify on tofu tests\"\n</code></pre> <ol> <li>Push to your branch: Push your changes to your forked repository.</li> </ol> <pre><code>git push origin my-feature-branch\n</code></pre> <ol> <li>Create a Pull Request: Open a pull request to the main repository. Provide a clear description of your changes and any related issue numbers.</li> </ol>"},{"location":"repository/contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>Please note that this project is released with a Contributor Code of Conduct. By participating in this project you agree to abide by its terms.</p>"},{"location":"repository/contributing/#reporting-issues","title":"Reporting Issues","text":"<p>If you find a bug or have a feature request, please open an issue on GitHub. Be sure to include as much detail as possible.</p>"},{"location":"repository/contributing/#style-guide","title":"Style Guide","text":"<ul> <li>Follow the existing code style.</li> <li>Write clear, concise commit messages using the Conventional Commits standard.</li> </ul>"},{"location":"repository/contributing/#testing","title":"Testing","text":"<p>Please ensure that your changes pass all tests and do not break existing functionality. If you add new features, include tests for those features.</p>"},{"location":"repository/contributing/#getting-help","title":"Getting Help","text":"<p>If you need help, feel free to reach out by opening an issue or discussion.</p> <p>Thank you for contributing!</p>"},{"location":"repository/merging_strategy/","title":"Merging Strategy","text":"<p>This project implements what is called: \"Apply after Merge\". This means that once the PR has been approved and merged into a base branch, a workflow is kicked off which then \"applies\" those changes. Another way of applying infrastructure changes is \"Apply before Merge\" - where the <code>tofu apply</code> runs in the context of the PR following an approval. There is quite a bit more to think about here such as:</p> <ol> <li>How do you trigger the apply?</li> <li>Which approval do you use as the authority to trigger an apply?</li> <li>How do you find this event information out?</li> </ol> <p>There is no right or wrong way of doing this personally, as long as it is understood by everyone using your repository what you are using that is fine. I've been using Terraform, and now OpenTofu for many years and I've always done \"Apply after Merge\" because that is what I am used too; doesn't mean it is right, or wrong and everyone is free to have their own opinion on the matter!</p> <p>For this minicamp, we create a feature branch and then raise a PR into <code>dev</code>. Once the checks have ran, and it has been approved and merged the <code>apply</code> kicks off. We then raise another PR from <code>dev</code> into <code>main</code> to deploy to production. I wanted to keep it as simple as possible </p>"},{"location":"repository/repo_settings/","title":"Repo Settings","text":"<p>To implement guardrails in branches for this project we used some native GitHub Functionality to meet the requirements of the bootcamp.</p>"},{"location":"repository/repo_settings/#rulesets","title":"Rulesets","text":"<p>This project has two rulesets that have been created:</p> <ol> <li><code>dev</code></li> <li><code>prod</code></li> </ol>"},{"location":"repository/repo_settings/#dev","title":"<code>dev</code>","text":"<p>This ruleset applies to the <code>dev</code> branch, meaning specific criteria has to be completed before anything can be merged into it. These are:</p> <ol> <li>Require a pull request before merging</li> <li>Require status checks to pass</li> </ol>"},{"location":"repository/repo_settings/#pull-request-before-merging","title":"Pull Request before Merging","text":"<p>Before anything can be pushed into <code>dev</code> it MUST come from a pull request. Additionally, the pull request has to be approved by at least one approver. This approver must come from the Code Owners (this is defined in <code>.github/CODEOWNERS</code>).</p> <p></p>"},{"location":"repository/repo_settings/#require-status-checks-to-pass","title":"Require status checks to pass","text":"<p>In addition to the above, status checks need to pass before it's possible to merge into <code>dev</code>. These checks are basically all the workflows I've created and documented on this site.</p> <p></p> <p>Only once both of the above are met, is it possible for a pull request to be merged into <code>dev</code></p>"},{"location":"repository/repo_settings/#prod","title":"<code>prod</code>","text":"<p>Now prod, or <code>main</code>, implements exactly the same protections as <code>dev</code> above, with one addition:</p> <ol> <li>Require deployments to succeed</li> </ol>"},{"location":"repository/repo_settings/#require-deployments-to-succeed","title":"Require Deployments to Succeed","text":"<p><code>tofu apply</code> only runs in the context of a GitHub Environment. Only if a successful deployment into the <code>dev</code> GitHub Environment - meaning a successful <code>tofu apply</code> in <code>dev</code>, is it possible for a <code>prod</code> or <code>main</code> deployment.</p> <p>To be clear, it uses the SAME protections as <code>dev</code> in that a PR must be made before merging AND status checks need to pass. It's just this one addition is also added for <code>prod</code>.</p>"},{"location":"repository/repo_settings/#github-environments","title":"GitHub Environments","text":"<p>This repository also implements GitHub Environments, and these are used in this project to ensure human intervention is required before a <code>tofu apply</code> or <code>tofu destroy</code> is allowed to run. We specify certain reviewers that are allowed to approve a workflow to run in <code>dev</code> and <code>prod</code> GitHub environments. In addition, only the related branch is allowed to deploy into that environment. So for the <code>prod</code> GitHub Environment that is <code>main</code> and for the <code>dev</code> GitHub Environment that is the <code>dev</code> branch.</p> <p>You can see a screenshot of how this is implemented in <code>prod</code> but it's the same for <code>dev</code> - just obviously only allowing the <code>dev</code> branch.</p> <p></p>"},{"location":"repository/repo_structure/","title":"Repo Structure","text":"<p>This page documents the repository structure, and its purpose as part of the workflows.</p> <ul> <li><code>.github</code> - contains all the workflows along with additional helper files</li> <li><code>docs</code> - contains all the documentation you are reading this on!</li> <li><code>policies</code> - contains all OPA policies</li> <li><code>tofu</code> - contains the OpenTofu configuration for the repository</li> <li><code>.checkov.yml</code> - the configuration file for <code>checkov</code></li> <li><code>.cspell.yml</code> - the configuration file for <code>cspell</code></li> <li><code>.editorconfig</code> - the configuration file for EditorConfig</li> <li><code>.gitignore</code> - Files to exclude from being committed to the repository</li> <li><code>.markdownlint-cli2.yaml</code> - Configuration file for orcestrating the <code>markdownlint</code> CLI</li> <li><code>.markdownlint.yml</code> - Configuration file containing the standards to enforce for <code>markdownlint</code></li> <li><code>.pre-commit-config.yaml</code> - Contain the hooks to run as part of the <code>pre-commit</code> framework</li> <li><code>.terraform-docs.yml</code> - Configuration file for <code>terraform-docs</code></li> <li><code>.tflint.hcl</code> - Configuration file for <code>tflint</code></li> <li><code>.trivy.yml</code> - Configuration file for <code>Trivy</code></li> <li><code>LICENSE</code> - License information for the repository</li> <li><code>mkdocs.yml</code> - Configuration file for generating the documentation using <code>mkdocs</code></li> <li><code>README.md</code> - Basic README containing key information about the project/repo</li> </ul>"},{"location":"repository/toolchain/","title":"Toolchain","text":"<p>This page documents what tools I used in this Minicamp that GitHub Actions runs!</p>"},{"location":"repository/toolchain/#opentofu","title":"OpenTofu","text":"<p>OpenTofu is the IaC tool used to deploy the infrastructure into the AWS accounts! It is the pure open-source fork of HashiCorp's Terraform where it changed its license to BSL (Business Source License) which sparked outrage in the community. I don't want to start a war on OpenTofu vs Terraform, but OpenTofu has been making some awesome changes that the Terraform community has been asking for a very long time, some examples:</p> <ol> <li>Native integration for state/plan file encryption</li> <li>Early variable evaluation</li> <li>Very new in the latest Alpha version for 1.9.0 - <code>for_each</code> at the <code>provider</code> level</li> </ol> <p>You should make your own decision on what tool you want to use, but competition is good for all of as consumers!</p> <ul> <li>https://opentofu.org/</li> </ul>"},{"location":"repository/toolchain/#infracost","title":"Infracost","text":"<p>Infracost is a FinOps tool that integrates with CI/CD pipelines to bring the cost topic at the point changes are made to infrastructure, which are Pull Requests. While we used the free offering for this Minicamp, it does have a SaaS product where you can create custom policies, dashboards and more.</p> <ul> <li>https://www.infracost.io/</li> </ul>"},{"location":"repository/toolchain/#open-policy-agent","title":"Open Policy Agent","text":"<p>OPA is a Policy-as-Code engine that defines policies using Rego. We create a rego policy as part of this camp, but it is only used in the scope of Infracost integration. It is backed by the Cloud Native Computing Foundation and is fully open-source</p> <ul> <li>https://www.openpolicyagent.org/</li> </ul>"},{"location":"repository/toolchain/#checkov","title":"checkov","text":"<p>checkov is a SAST tool that scans your configuration for best practices and potential security issues. It has a massive amount of checks and scans for things such as:</p> <ol> <li>Overpermissive IAM policies</li> <li>Delete protection enabled on DynamoDB tables</li> <li>Public resource exposure</li> <li> <p>Port 22 open to the world</p> </li> <li> <p>https://www.checkov.io/</p> </li> </ol>"},{"location":"repository/toolchain/#trivy","title":"Trivy","text":"<p>Trivy is similar to <code>checkov</code> - it scans your code for best practices and potential security issues. It can even scan your workflows to make sure they are secure, such as using commit SHAs to prevent supply-chain attacks.</p> <ul> <li>https://trivy.dev/</li> </ul>"},{"location":"repository/toolchain/#markdownlint","title":"markdownlint","text":"<p>Markdownlint, as you might be able to tell, lints markdown documents so they are formatted to a standard across the entire repository. For example, using <code>*</code> or <code>_</code> for emphasis in text and more.</p> <ul> <li>https://github.com/DavidAnson/markdownlint</li> </ul>"},{"location":"repository/toolchain/#tflint","title":"tflint","text":"<p>tflint is used to scan your OpenTofu/Terraform for quality such as deprecations, naming conventions and best practices.</p> <ul> <li>https://github.com/terraform-linters/tflint</li> </ul>"},{"location":"repository/toolchain/#terraform-docs","title":"terraform-docs","text":"<p>Used to produce good documentation on your OpenTofu/Terraform configuration such as versions, providers, modules, variables and their descriptions in a easy to read markdown format.</p> <ul> <li>https://github.com/terraform-docs/terraform-docs</li> </ul>"},{"location":"repository/toolchain/#cspell","title":"cspell","text":"<p>Spell check your code for spelling mistakes!</p> <ul> <li>https://cspell.org/</li> </ul>"},{"location":"repository/toolchain/#material-for-mkdocs","title":"Material for Mkdocs","text":"<p>A theme for the <code>Mkdocs</code> framework that builds beautiful documentation sites! Documentation-as-Code!</p> <ul> <li>https://squidfunk.github.io/mkdocs-material/</li> </ul>"},{"location":"repository/toolchain/#pre-commit","title":"pre-commit","text":"<p>A framework for running pre-commit hooks before they are committed to the repository.</p> <ul> <li>https://pre-commit.com/</li> </ul>"},{"location":"repository/toolchain/#editorconfig","title":"EditorConfig","text":"<p>A common standard for editing files in their IDE of choice such as enforcing utf-8 and Linux line endings, spacing, tabs or spaces and more!</p> <ul> <li>https://editorconfig.org/</li> </ul>"},{"location":"repository/toolchain/#dependabot","title":"Dependabot","text":"<p>GitHub's native bot for updates dependencies in your code!</p> <ul> <li>https://github.com/dependabot</li> </ul>"}]}